import{_ as n,c as s,a as e,o as d}from"./app-Bpj5Mkzv.js";const a={};function i(l,t){return d(),s("div",null,t[0]||(t[0]=[e(`<h1 id="_3234-统计-1-显著的字符串的数量" tabindex="-1"><a class="header-anchor" href="#_3234-统计-1-显著的字符串的数量"><span><a href="https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/" target="_blank" rel="noopener noreferrer">3234. 统计 1 显著的字符串的数量</a></span></a></h1><p>给你一个二进制字符串 <code>s</code>。</p><p>请你统计并返回其中 <strong>1 显著</strong> 的 子字符串 的数量。</p><p>如果字符串中 1 的数量 <strong>大于或等于</strong> 0 的数量的 <strong>平方</strong>，则认为该字符串是一个 <strong>1 显著</strong> 的字符串 。</p><p><strong>示例 1：</strong></p><p>**输入：**s = &quot;00011&quot;</p><p>**输出：**5</p><p><strong>解释：</strong></p><p>1 显著的子字符串如下表所示。</p><table><thead><tr><th>i</th><th>j</th><th>s[i..j]</th><th>0 的数量</th><th>1 的数量</th></tr></thead><tbody><tr><td>3</td><td>3</td><td>1</td><td>0</td><td>1</td></tr><tr><td>4</td><td>4</td><td>1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>3</td><td>01</td><td>1</td><td>1</td></tr><tr><td>3</td><td>4</td><td>11</td><td>0</td><td>2</td></tr><tr><td>2</td><td>4</td><td>011</td><td>1</td><td>2</td></tr></tbody></table><p><strong>示例 2：</strong></p><p>**输入：**s = &quot;101101&quot;</p><p>**输出：**16</p><p><strong>解释：</strong></p><p>1 不显著的子字符串如下表所示。</p><p>总共有 21 个子字符串，其中 5 个是 1 不显著字符串，因此有 16 个 1 显著子字符串。</p><table><thead><tr><th>i</th><th>j</th><th>s[i..j]</th><th>0 的数量</th><th>1 的数量</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>4</td><td>4</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>4</td><td>0110</td><td>2</td><td>2</td></tr><tr><td>0</td><td>4</td><td>10110</td><td>2</td><td>3</td></tr><tr><td>1</td><td>5</td><td>01101</td><td>2</td><td>3</td></tr></tbody></table><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 4 * 104</code></li><li><code>s</code> 仅包含字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code>。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>通过维护所有 <code>&#39;0&#39;</code> 的位置，并在遍历字符串时，对每个右端点 <code>r</code>，利用已记录的 <code>&#39;0&#39;</code> 位置和当前 <code>&#39;1&#39;</code> 的总数，枚举以 <code>r</code> 结尾、满足“0 的个数的平方 ≤ 1 的个数”的子串数量，从而高效统计符合条件的子串总数。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    int numberOfSubstrings(string s) {</span>
<span class="line">        vector&lt;int&gt; pos0 = {-1}; // 加个 -1 哨兵，方便处理 cnt0 达到最大时的计数</span>
<span class="line">        int total1 = 0; // [0,r] 中的 1 的个数</span>
<span class="line">        int ans = 0;</span>
<span class="line">        for (int r = 0; r &lt; s.size(); r++) {</span>
<span class="line">            if (s[r] == &#39;0&#39;) {</span>
<span class="line">                pos0.push_back(r); // 记录 0 的下标</span>
<span class="line">            } else {</span>
<span class="line">                total1++;</span>
<span class="line">                ans += r - pos0.back(); // 单独计算不含 0 的子串个数</span>
<span class="line">            }</span>
<span class="line"></span>
<span class="line">            int m = pos0.size();</span>
<span class="line">            // 倒着遍历 pos0，那么 cnt0 = m - i</span>
<span class="line">            for (int i = m - 1; i &gt; 0 &amp;&amp; (m - i) * (m - i) &lt;= total1; i--) {</span>
<span class="line">                int p = pos0[i - 1], q = pos0[i];</span>
<span class="line">                int cnt0 = m - i;</span>
<span class="line">                int cnt1 = r - q + 1 - cnt0; // [q,r] 中的 1 的个数 = [q,r] 的长度 - cnt0</span>
<span class="line">                ans += max(q - max(cnt0 * cnt0 - cnt1, 0) - p, 0);</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return ans;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n√n)</li><li>空间复杂度：O(n)</li></ul>`,24)]))}const p=n(a,[["render",i]]),c=JSON.parse('{"path":"/leetcode/20251115.html","title":"3234. 统计 1 显著的字符串的数量","lang":"zh-CN","frontmatter":{"date":"2025-11-15T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["字符串","枚举","滑动窗口"]},"headers":[],"git":{"updatedTime":1763518154000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":1,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"4b5123a2226ab3055587cb87c78becf08ce40201","time":1763518154000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20251115.md","excerpt":"\\n<p>给你一个二进制字符串 <code>s</code>。</p>\\n<p>请你统计并返回其中 <strong>1 显著</strong> 的 子字符串 的数量。</p>\\n<p>如果字符串中 1 的数量 <strong>大于或等于</strong> 0 的数量的 <strong>平方</strong>，则认为该字符串是一个 <strong>1 显著</strong> 的字符串 。</p>\\n<p><strong>示例 1：</strong></p>\\n<p>**输入：**s = \\"00011\\"</p>\\n<p>**输出：**5</p>\\n<p><strong>解释：</strong></p>\\n<p>1 显著的子字符串如下表所示。</p>"}');export{p as comp,c as data};
