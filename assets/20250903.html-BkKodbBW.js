import{_ as s,c as e,a as i,o as a}from"./app-CtcNptRb.js";const l={};function t(c,n){return a(),e("div",null,n[0]||(n[0]=[i(`<h1 id="_3027-人员站位的方案数-ii" tabindex="-1"><a class="header-anchor" href="#_3027-人员站位的方案数-ii"><span><a href="https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/" target="_blank" rel="noopener noreferrer">3027. 人员站位的方案数 II</a></span></a></h1><p>给你一个 <code>n x 2</code> 的二维数组 <code>points</code> ，它表示二维平面上的一些点坐标，其中 <code>points[i] = [xi, yi]</code> 。</p><p>我们定义 x 轴的正方向为 <strong>右</strong> （<strong>x 轴递增的方向</strong>），x 轴的负方向为 <strong>左</strong> （<strong>x 轴递减的方向</strong>）。类似的，我们定义 y 轴的正方向为 <strong>上</strong> （<strong>y 轴递增的方向</strong>），y 轴的负方向为 <strong>下</strong> （<strong>y 轴递减的方向</strong>）。</p><p>你需要安排这 <code>n</code> 个人的站位，这 <code>n</code> 个人中包括 Alice 和 Bob 。你需要确保每个点处 <strong>恰好</strong> 有 <strong>一个</strong> 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 <strong>左上角</strong> ，Bob 的坐标为 <strong>右下角</strong> 建立一个矩形的围栏（<strong>注意</strong>，围栏可能 <strong>不</strong> 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 <strong>内部</strong> 或者 <strong>边缘</strong> 上有任何其他人，Alice 都会难过。</p><p>请你在确保 Alice <strong>不会</strong> 难过的前提下，返回 Alice 和 Bob 可以选择的 <strong>点对</strong> 数目。</p><p><strong>注意</strong>，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 <code>(1, 1)</code> ，<code>(1, 3)</code> ，<code>(3, 1)</code> 和 <code>(3, 3)</code> 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：</p><ul><li>图一中，Alice 在 <code>(3, 3)</code> 且 Bob 在 <code>(1, 1)</code> ，Alice 的位置不是左上角且 Bob 的位置不是右下角。</li><li>图二中，Alice 在 <code>(1, 3)</code> 且 Bob 在 <code>(1, 1)</code> ，Bob 的位置不是在围栏的右下角。</li></ul><p><img src="https://assets.leetcode.com/uploads/2024/01/04/example0alicebob-1.png" alt="img"></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png" alt="img"></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span>
<span class="line">输出：0</span>
<span class="line">解释：没有办法可以让 Alice 的围栏以 Alice 的位置为左上角且 Bob 的位置为右下角。所以我们返回 0 。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><strong><a href="https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://pic.leetcode.cn/1708226715-CxjXKb-20240218-112338.jpeg" alt="img"></a></strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：points = [[6,2],[4,4],[2,6]]</span>
<span class="line">输出：2</span>
<span class="line">解释：总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：</span>
<span class="line">- Alice 站在 (4, 4) ，Bob 站在 (6, 2) 。</span>
<span class="line">- Alice 站在 (2, 6) ，Bob 站在 (4, 4) 。</span>
<span class="line">不能安排 Alice 站在 (2, 6) 且 Bob 站在 (6, 2) ，因为站在 (4, 4) 的人处于围栏内。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><p><strong><a href="https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://pic.leetcode.cn/1708226721-wTbEuK-20240218-112351.jpeg" alt="img"></a></strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：points = [[3,1],[1,3],[1,1]]</span>
<span class="line">输出：2</span>
<span class="line">解释：总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：</span>
<span class="line">- Alice 站在 (1, 1) ，Bob 站在 (3, 1) 。</span>
<span class="line">- Alice 站在 (1, 3) ，Bob 站在 (1, 1) 。</span>
<span class="line">不能安排 Alice 站在 (1, 3) 且 Bob 站在 (3, 1) ，因为站在 (1, 1) 的人处于围栏内。</span>
<span class="line">注意围栏是可以不包含任何面积的，上图中第一和第二个围栏都是合法的。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>points[i].length == 2</code></li><li><code>-109 &lt;= points[i][0], points[i][1] &lt;= 109</code></li><li><code>points[i]</code> 点对两两不同。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>解法与昨天的每日一题一致，昨天的官解因为数据量小，用的是暴力法，复杂度n3</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {</span>
<span class="line">        sort(points.begin(),points.end(),[](const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b){</span>
<span class="line">            return a[0]&lt;b[0]||(a[0]==b[0]&amp;&amp;a[1]&gt;b[1]);</span>
<span class="line">        });</span>
<span class="line">        int n=points.size();</span>
<span class="line">        int ans=0;</span>
<span class="line">        for(int i=0;i&lt;n;i++){</span>
<span class="line">            int y1=points[i][1];</span>
<span class="line">            int max_y=INT_MIN;</span>
<span class="line">            for(int j=i+1;j&lt;n;j++){</span>
<span class="line">                int y2=points[j][1];</span>
<span class="line">                if(y2&gt;max_y&amp;&amp;y2&lt;=y1){</span>
<span class="line">                    max_y=y2;</span>
<span class="line">                    ans++;</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return ans;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul>`,24)]))}const r=s(l,[["render",t]]),p=JSON.parse('{"path":"/leetcode/20250903.html","title":"3027. 人员站位的方案数 II","lang":"zh-CN","frontmatter":{"date":"2025-09-03T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","数学","排序"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"3438719330b4dbd40a16ffa76baba189cda0f907","time":1756862889000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250903.md","excerpt":"\\n<p>给你一个 <code>n x 2</code> 的二维数组 <code>points</code> ，它表示二维平面上的一些点坐标，其中 <code>points[i] = [xi, yi]</code> 。</p>\\n<p>我们定义 x 轴的正方向为 <strong>右</strong> （<strong>x 轴递增的方向</strong>），x 轴的负方向为 <strong>左</strong> （<strong>x 轴递减的方向</strong>）。类似的，我们定义 y 轴的正方向为 <strong>上</strong> （<strong>y 轴递增的方向</strong>），y 轴的负方向为 <strong>下</strong> （<strong>y 轴递减的方向</strong>）。</p>"}');export{r as comp,p as data};
