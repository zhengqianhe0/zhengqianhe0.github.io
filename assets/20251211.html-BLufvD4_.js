import{_ as e,c as s,a as i,o as l}from"./app-Bpj5Mkzv.js";const a={};function t(c,n){return l(),s("div",null,n[0]||(n[0]=[i(`<h1 id="_3531-统计被覆盖的建筑" tabindex="-1"><a class="header-anchor" href="#_3531-统计被覆盖的建筑"><span><a href="https://leetcode.cn/problems/count-covered-buildings/" target="_blank" rel="noopener noreferrer">3531. 统计被覆盖的建筑</a></span></a></h1><p>给你一个正整数 <code>n</code>，表示一个 <code>n x n</code> 的城市，同时给定一个二维数组 <code>buildings</code>，其中 <code>buildings[i] = [x, y]</code> 表示位于坐标 <code>[x, y]</code> 的一个 <strong>唯一</strong> 建筑。</p><p>如果一个建筑在四个方向（左、右、上、下）中每个方向上都至少存在一个建筑，则称该建筑 <strong>被覆盖</strong> 。</p><p>返回 <strong>被覆盖</strong> 的建筑数量。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1745660407-qtNUjI-telegram-cloud-photo-size-5-6212982906394101085-m.jpg" alt="img"></p><p><strong>输入:</strong> n = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong></p><ul><li><p>只有建筑</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[2,2]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>被覆盖，因为它在每个方向上都至少存在一个建筑：</p><ul><li>上方 (<code>[1,2]</code>)</li><li>下方 (<code>[3,2]</code>)</li><li>左方 (<code>[2,1]</code>)</li><li>右方 (<code>[2,3]</code>)</li></ul></li><li><p>因此，被覆盖的建筑数量是 1。</p></li></ul><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode.cn/1745660407-tUMUKl-telegram-cloud-photo-size-5-6212982906394101086-m.jpg" alt="img"></p><p><strong>输入:</strong> n = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]</p><p><strong>输出:</strong> 0</p><p><strong>解释:</strong></p><ul><li>没有任何一个建筑在每个方向上都有至少一个建筑。</li></ul><p><strong>示例 3：</strong></p><p><img src="https://pic.leetcode.cn/1745660407-bQIwBX-telegram-cloud-photo-size-5-6248862251436067566-x.jpg" alt="img"></p><p><strong>输入:</strong> n = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong></p><ul><li><p>只有建筑</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[3,3]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>被覆盖，因为它在每个方向上至少存在一个建筑：</p><ul><li>上方 (<code>[1,3]</code>)</li><li>下方 (<code>[5,3]</code>)</li><li>左方 (<code>[3,2]</code>)</li><li>右方 (<code>[3,5]</code>)</li></ul></li><li><p>因此，被覆盖的建筑数量是 1。</p></li></ul><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= buildings.length &lt;= 105</code></li><li><code>buildings[i] = [x, y]</code></li><li><code>1 &lt;= x, y &lt;= n</code></li><li><code>buildings</code> 中所有坐标均 <strong>唯一</strong> 。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>第一次遍历找每一行，每一列的最小值和最大值</p><p>第二次遍历判断每个建筑是否满足在最大值和最小值之间</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    int countCoveredBuildings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {</span>
<span class="line">        vector&lt;int&gt; row_min(n + 1, INT_MAX), row_max(n + 1);</span>
<span class="line">        vector&lt;int&gt; col_min(n + 1, INT_MAX), col_max(n + 1);</span>
<span class="line">        for (auto&amp; p : buildings) {</span>
<span class="line">            int x = p[0], y = p[1];</span>
<span class="line">            row_min[y] = min(row_min[y], x);</span>
<span class="line">            row_max[y] = max(row_max[y], x);</span>
<span class="line">            col_min[x] = min(col_min[x], y);</span>
<span class="line">            col_max[x] = max(col_max[x], y);</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        int ans = 0;</span>
<span class="line">        for (auto&amp; p : buildings) {</span>
<span class="line">            int x = p[0], y = p[1];</span>
<span class="line">            if (row_min[y] &lt; x &amp;&amp; x &lt; row_max[y] &amp;&amp; col_min[x] &lt; y &amp;&amp; y &lt; col_max[x]) {</span>
<span class="line">                ans++;</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return ans;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n+m)</li><li>空间复杂度：O(n)</li></ul>`,30)]))}const d=e(a,[["render",t]]),p=JSON.parse('{"path":"/leetcode/20251211.html","title":"3531. 统计被覆盖的建筑","lang":"zh-CN","frontmatter":{"date":"2025-12-11T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","哈希表","排序"]},"headers":[],"git":{"updatedTime":1766800992000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":1,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"f7994bdc2b7d79487139c25b9441948e02916a3e","time":1766800992000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20251211.md","excerpt":"\\n<p>给你一个正整数 <code>n</code>，表示一个 <code>n x n</code> 的城市，同时给定一个二维数组 <code>buildings</code>，其中 <code>buildings[i] = [x, y]</code> 表示位于坐标 <code>[x, y]</code> 的一个 <strong>唯一</strong> 建筑。</p>\\n<p>如果一个建筑在四个方向（左、右、上、下）中每个方向上都至少存在一个建筑，则称该建筑 <strong>被覆盖</strong> 。</p>\\n<p>返回 <strong>被覆盖</strong> 的建筑数量。</p>\\n<p><strong>示例 1：</strong></p>"}');export{d as comp,p as data};
