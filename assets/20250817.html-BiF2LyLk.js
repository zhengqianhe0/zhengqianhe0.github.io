import{_ as s,c as n,a,o as i}from"./app-CtcNptRb.js";const l={};function d(p,e){return i(),n("div",null,e[0]||(e[0]=[a(`<h1 id="_837-新-21-点" tabindex="-1"><a class="header-anchor" href="#_837-新-21-点"><span><a href="https://leetcode.cn/problems/new-21-game/" target="_blank" rel="noopener noreferrer">837. 新 21 点</a></span></a></h1><p>爱丽丝参与一个大致基于纸牌游戏 <strong>“21点”</strong> 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>k</code> 分时抽取数字。 抽取时，她从 <code>[1, maxPts]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>maxPts</code> 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得 <code>k</code> 分 <strong>或更多分</strong> 时，她就停止抽取数字。</p><p>爱丽丝的分数不超过 <code>n</code> 的概率是多少？</p><p>与实际答案误差不超过 <code>10-5</code> 的答案将被视为正确答案。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：n = 10, k = 1, maxPts = 10</span>
<span class="line">输出：1.00000</span>
<span class="line">解释：爱丽丝得到一张牌，然后停止。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：n = 6, k = 1, maxPts = 10</span>
<span class="line">输出：0.60000</span>
<span class="line">解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：n = 21, k = 17, maxPts = 10</span>
<span class="line">输出：0.73278</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= n &lt;= 104</code></li><li><code>1 &lt;= maxPts &lt;= 104</code></li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>解题思路 老实说，一开始没懂题目意思，后面才知道是求爱丽丝的胜率。 规则是这样：</p><p>她可以从牌面为 [1,W] 的牌中选择任意一张，这张牌是可以无限重复的，也就是说无论她取多少次，每次取到 2（假如 2 在 [1,W] 范围内）的概率都是 1/W; 如果她手上牌的总额小于 K，她就会抽牌，大于等于 K 时，就停止抽牌; 停止抽牌后，她的牌面小于等于 N 时，她就获胜了，求她获胜的概率。 假设 dp[x] 为她手上牌面为x时，能获胜的概率，那么这个概率应该是： dp[x]=1/w * (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+w]) 因为抽取的牌面机会都是均等的，她能抽取的面值在 [1,W] 之间，所以将概率之和平均一下就是 dp[x] 的概率。</p><p>强插一段解释： x代表爱丽丝手上的牌面值，dp[x]代表爱丽丝手上持有的牌面值为x时，她获胜的概率（游戏结束时她所持牌面值小于等于N的概率）。 这个概率是怎么来的？x分2种情况:</p><p>当x&gt;=K时，爱丽丝会停止抽牌，这个时候游戏已经结束了，她是赢是输也已经确定了，所以此时赢的概率要么1，要么0 当x&lt;K时，爱丽丝会继续抽牌，抽牌是有概率的，所以她是赢是输也有概率。 她能抽到的牌面值在 [1,W] 之间，所以抽完后她的牌面在[x+1,x+w]之间，因为每张牌机率均等，所以抽完后牌面在[x+1,x+w]之间的每个面值概率都是相等的，而假如我们已知当牌面是[x+1,x+w]的胜率(即dp[x+1]...dp[x+w]的值)，那么可以推导：</p><p>dp[x]=1/w * dp[x+1]+ 1/w * dp[x+2] + 1/w * dp[x+3]...+ 1/w * dp[x+w]</p><p>这个实际上就是动态规划的状态转移方程，不过本例是反着来转移的。 x 最多能到 K-1，因为当大于等于 K 时，爱丽丝会停止抽牌，所以当游戏结束时，即爱丽丝停止抽牌时，她可能达到的最大牌面是 K+W-1，而一开始她的牌面是 0，所以我们用一个长度为 K+W 的 dp 数组来保存她在所有面值下的胜率。 最后 dp[0]，也就是最开始爱丽丝还没有抽牌，她的牌面为 0 时的胜率，这个就是我们的答案。</p><p>填格子游戏开始</p><p>我将这个格子分成了 2 部分 [0,K-1] 和 [K,K+W-1]，区别就是 [0,K-1] 爱丽丝可以抽牌，[K,K+W-1] 时不能抽牌，那么不能抽牌时她获胜的概率是多少呢，此时已不能抽牌，要么赢要么输，很显然牌面小于等于N时，概率就是 1，大于 N 概率就是 0，所以先直接填满图中蓝色的格子。</p><p>接下来，从 K-1 开始填图中的橘色部分，这个值根据我们前面提到的计算方式，实际上就相当于它后面 W 个格子的总和除以 W， 这时聪明的你一定会想到不用每轮都累加的方法吧，用一个 s 变量来保存累加结果，而下一轮只是减去右边的格子，加上左边的格子即可。</p><p>所以这题你要做的就是，先初始化蓝色格子，然后从最右边的橘色格子开始，填到最左边的格子，就是这么简单，不仅简单，而且你连动态规划的思想都学会了。 相信这么厉害的你，看到这里给我点个赞一定不是件很困难的事吧。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    double new21Game(int n, int k, int maxPts) {</span>
<span class="line">        vector&lt;double&gt; dp(k+maxPts);</span>
<span class="line">        double s=0;</span>
<span class="line">        for(int i=k;i&lt;k+maxPts;i++){</span>
<span class="line">            if(i&lt;=n){</span>
<span class="line">                dp[i]=1;</span>
<span class="line">            }else{</span>
<span class="line">                dp[i]=0;</span>
<span class="line">            }</span>
<span class="line">            s+=dp[i];</span>
<span class="line">        }</span>
<span class="line">        for(int i=k-1;i&gt;=0;i--){</span>
<span class="line">            dp[i]=s/maxPts;</span>
<span class="line">            s=s-dp[i+maxPts]+dp[i];</span>
<span class="line">        }</span>
<span class="line">        return dp[0];</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(k+max)</li><li>空间复杂度：O(k+max)</li></ul>`,28)]))}const t=s(l,[["render",d]]),r=JSON.parse('{"path":"/leetcode/20250817.html","title":"837. 新 21 点","lang":"zh-CN","frontmatter":{"date":"2025-08-17T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数学","概率与统计","动态规划","滑动窗口"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"2d27c3c183ce37bd5641dc3abcefd05ca4e818d8","time":1755400549000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250817.md","excerpt":"\\n<p>爱丽丝参与一个大致基于纸牌游戏 <strong>“21点”</strong> 规则的游戏，描述如下：</p>\\n<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>k</code> 分时抽取数字。 抽取时，她从 <code>[1, maxPts]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>maxPts</code> 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。</p>\\n<p>当爱丽丝获得 <code>k</code> 分 <strong>或更多分</strong> 时，她就停止抽取数字。</p>\\n<p>爱丽丝的分数不超过 <code>n</code> 的概率是多少？</p>"}');export{t as comp,r as data};
