import{_ as s,c as e,a as i,o as l}from"./app-CtcNptRb.js";const a={};function d(c,n){return l(),e("div",null,n[0]||(n[0]=[i(`<h1 id="_3459-最长-v-形对角线段的长度" tabindex="-1"><a class="header-anchor" href="#_3459-最长-v-形对角线段的长度"><span><a href="https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/" target="_blank" rel="noopener noreferrer">3459. 最长 V 形对角线段的长度</a></span></a></h1><p>给你一个大小为 <code>n x m</code> 的二维整数矩阵 <code>grid</code>，其中每个元素的值为 <code>0</code>、<code>1</code> 或 <code>2</code>。</p><p><strong>V 形对角线段</strong> 定义如下：</p><ul><li>线段从 <code>1</code> 开始。</li><li>后续元素按照以下无限序列的模式排列：<code>2, 0, 2, 0, ...</code>。</li><li>该线段： <ul><li>起始于某个对角方向（左上到右下、右下到左上、右上到左下或左下到右上）。</li><li>沿着相同的对角方向继续，保持 <strong>序列模式</strong> 。</li><li>在保持 <strong>序列模式</strong> 的前提下，最多允许 <strong>一次顺时针 90 度转向</strong> 另一个对角方向。</li></ul></li></ul><p><img src="https://pic.leetcode.cn/1739609732-jHpPma-length_of_longest3.jpg" alt="img"></p><p>返回最长的 <strong>V 形对角线段</strong> 的 <strong>长度</strong> 。如果不存在有效的线段，则返回 0。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong> grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</p><p><strong>输出：</strong> 5</p><p><strong>解释：</strong></p><p><img src="https://pic.leetcode.cn/1739609768-rhePxN-matrix_1-2.jpg" alt="img"></p><p>最长的 V 形对角线段长度为 5，路径如下：<code>(0,2) → (1,3) → (2,4)</code>，在 <code>(2,4)</code> 处进行 <strong>顺时针 90 度转向</strong> ，继续路径为 <code>(3,3) → (4,2)</code>。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong> grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</p><p><strong>输出：</strong> 4</p><p><strong>解释：</strong></p><p><img src="https://pic.leetcode.cn/1739609774-nYJElV-matrix_2.jpg" alt="img"></p><p>最长的 V 形对角线段长度为 4，路径如下：<code>(2,3) → (3,2)</code>，在 <code>(3,2)</code> 处进行 <strong>顺时针 90 度转向</strong> ，继续路径为 <code>(2,1) → (1,0)</code>。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]</p><p><strong>输出：</strong> 5</p><p><strong>解释：</strong></p><p><img src="https://pic.leetcode.cn/1739609780-tlkdUW-matrix_3.jpg" alt="img"></p><p>最长的 V 形对角线段长度为 5，路径如下：<code>(0,0) → (1,1) → (2,2) → (3,3) → (4,4)</code>。</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong> grid = [[1]]</p><p><strong>输出：</strong> 1</p><p><strong>解释：</strong></p><p>最长的 V 形对角线段长度为 1，路径如下：<code>(0,0)</code>。</p><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>m == grid[i].length</code></li><li><code>1 &lt;= n, m &lt;= 500</code></li><li><code>grid[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code>。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>这段代码用于求解二维网格中 &quot;最长 V 形对角线片段&quot; 的长度。V 形片段的定义是：以值为 1 的单元格为起点，沿对角线方向延伸，由 1 和 2 交替组成，且最多允许一次顺时针 90° 转向（形成 &quot;V&quot; 字形状）。</p><h3 id="核心逻辑分析" tabindex="-1"><a class="header-anchor" href="#核心逻辑分析"><span>核心逻辑分析</span></a></h3><ol><li><strong>方向定义</strong>：<code>dirs</code>数组定义了 4 个对角线方向：<code>{1,1}</code>（右下）、<code>{1,-1}</code>（左下）、<code>{-1,-1}</code>（左上）、<code>{-1,1}</code>（右上）。</li><li><strong>记忆化存储</strong>：<code>memo</code>是一个四维数组<code>[m][n][4][2]</code>，用于缓存计算结果，避免重复递归： <ul><li>前两维：当前坐标<code>(nx, ny)</code></li><li>第三维：当前移动方向（0-3）</li><li>第四维：是否允许转向（<code>true</code>/<code>false</code>，对应 1/0）</li></ul></li><li><strong>DFS 递归函数</strong>：通过深度优先搜索计算最长 V 形片段： <ul><li>计算下一个坐标<code>(nx, ny)</code>，若越界或值不等于目标值（1 和 2 交替），返回 0</li><li>若<code>memo</code>中已有缓存结果，直接返回</li><li>否则递归计算： <ul><li>沿原方向继续延伸（目标值切换为<code>2 - target</code>，实现 1 和 2 交替）</li><li>若允许转向（<code>turn=true</code>），尝试顺时针转 90°（方向<code>(direction+1)%4</code>）并禁止再次转向</li></ul></li><li>缓存结果并返回（当前步长 + 1）</li></ul></li><li><strong>主循环</strong>：遍历所有值为 1 的单元格，从 4 个方向开始 DFS，更新最长片段长度。</li></ol><h3 id="时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#时间复杂度分析"><span>时间复杂度分析</span></a></h3><ul><li><strong>状态总数</strong>：<code>memo</code>数组的大小为<code>m × n × 4 × 2</code>（网格大小 ×4 个方向 ×2 种转向状态）</li><li><strong>每个状态计算</strong>：每个状态仅计算一次，每次递归操作是 O (1)</li><li><strong>总复杂度</strong>：O (m・n)（4 和 2 是常数，可忽略）</li></ul><h3 id="空间复杂度分析" tabindex="-1"><a class="header-anchor" href="#空间复杂度分析"><span>空间复杂度分析</span></a></h3><ul><li><strong>记忆化数组</strong>：<code>memo</code>占用 O (m・n・4・2) = O (m・n) 空间</li><li><strong>递归栈深度</strong>：最坏情况下递归深度为 O (m・n)（沿对角线遍历整个网格）</li><li><strong>总复杂度</strong>：O(m·n)</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">private:</span>
<span class="line">    int dfs(int cx, int cy, int direction, bool turn, int target,</span>
<span class="line">            const vector&lt;vector&lt;int&gt;&gt;&amp; grid, const int dirs[4][2],</span>
<span class="line">            int memo[505][505][4][2]) {</span>
<span class="line">        int m = grid.size();</span>
<span class="line">        int n = grid[0].size();</span>
<span class="line">        int nx = cx + dirs[direction][0];</span>
<span class="line">        int ny = cy + dirs[direction][1];</span>
<span class="line">        </span>
<span class="line">        if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || grid[nx][ny] != target) {</span>
<span class="line">            return 0;</span>
<span class="line">        }</span>
<span class="line">        </span>
<span class="line">        if (memo[nx][ny][direction][turn] != -1) {</span>
<span class="line">            return memo[nx][ny][direction][turn];</span>
<span class="line">        }</span>
<span class="line">        </span>
<span class="line">        int maxStep = dfs(nx, ny, direction, turn, 2 - target, grid, dirs, memo);</span>
<span class="line">        if (turn) {</span>
<span class="line">            maxStep = max(maxStep,</span>
<span class="line">                          dfs(nx, ny, (direction + 1) % 4, false, 2 - target, grid, dirs, memo));</span>
<span class="line">        }</span>
<span class="line">        </span>
<span class="line">        memo[nx][ny][direction][turn] = maxStep + 1;</span>
<span class="line">        return maxStep + 1;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">public:</span>
<span class="line">    inline int lenOfVDiagonal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</span>
<span class="line">        int m = grid.size();</span>
<span class="line">        if (m == 0) return 0;</span>
<span class="line">        int n = grid[0].size();</span>
<span class="line">        int dirs[4][2] = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};</span>
<span class="line">        // 静态创建数组</span>
<span class="line">        static int memo[505][505][4][2];</span>
<span class="line">        memset(memo, -1, sizeof(memo));</span>
<span class="line">        </span>
<span class="line">        int res = 0;</span>
<span class="line">        for (int i = 0; i &lt; m; ++i) {</span>
<span class="line">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="line">                if (grid[i][j] == 1) {</span>
<span class="line">                    for (int direction = 0; direction &lt; 4; ++direction) {</span>
<span class="line">                        res = max(res, dfs(i, j, direction, true, 2, grid, dirs, memo) + 1);</span>
<span class="line">                    }</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return res;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul>`,42)]))}const t=s(a,[["render",d]]),o=JSON.parse('{"path":"/leetcode/20250827.html","title":"3459. 最长 V 形对角线段的长度","lang":"zh-CN","frontmatter":{"date":"2025-08-27T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","记忆化搜索","动态规划"]},"headers":[{"level":3,"title":"核心逻辑分析","slug":"核心逻辑分析","link":"#核心逻辑分析","children":[]},{"level":3,"title":"时间复杂度分析","slug":"时间复杂度分析","link":"#时间复杂度分析","children":[]},{"level":3,"title":"空间复杂度分析","slug":"空间复杂度分析","link":"#空间复杂度分析","children":[]}],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"4937944c47ddde9e53e505ebe15db8b7d3ab8d48","time":1756266240000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250827.md","excerpt":"\\n<p>给你一个大小为 <code>n x m</code> 的二维整数矩阵 <code>grid</code>，其中每个元素的值为 <code>0</code>、<code>1</code> 或 <code>2</code>。</p>\\n<p><strong>V 形对角线段</strong> 定义如下：</p>\\n<ul>\\n<li>线段从 <code>1</code> 开始。</li>\\n<li>后续元素按照以下无限序列的模式排列：<code>2, 0, 2, 0, ...</code>。</li>\\n<li>该线段：\\n<ul>\\n<li>起始于某个对角方向（左上到右下、右下到左上、右上到左下或左下到右上）。</li>\\n<li>沿着相同的对角方向继续，保持 <strong>序列模式</strong> 。</li>\\n<li>在保持 <strong>序列模式</strong> 的前提下，最多允许 <strong>一次顺时针 90 度转向</strong> 另一个对角方向。</li>\\n</ul>\\n</li>\\n</ul>"}');export{t as comp,o as data};
