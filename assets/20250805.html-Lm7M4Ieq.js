import{_ as e,c as n,a as i,o as t}from"./app-Bpj5Mkzv.js";const a={};function l(o,s){return t(),n("div",null,s[0]||(s[0]=[i(`<h1 id="_3477-水果成篮-ii" tabindex="-1"><a class="header-anchor" href="#_3477-水果成篮-ii"><span><a href="https://leetcode.cn/problems/fruits-into-baskets-ii/" target="_blank" rel="noopener noreferrer">3477. 水果成篮 II</a></span></a></h1><p>给你两个长度为 <code>n</code> 的整数数组，<code>fruits</code> 和 <code>baskets</code>，其中 <code>fruits[i]</code> 表示第 <code>i</code> 种水果的 <strong>数量</strong>，<code>baskets[j]</code> 表示第 <code>j</code> 个篮子的 <strong>容量</strong>。</p><p>你需要对 <code>fruits</code> 数组从左到右按照以下规则放置水果：</p><ul><li>每种水果必须放入第一个 <strong>容量大于等于</strong> 该水果数量的 <strong>最左侧可用篮子</strong> 中。</li><li>每个篮子只能装 <strong>一种</strong> 水果。</li><li>如果一种水果 <strong>无法放入</strong> 任何篮子，它将保持 <strong>未放置</strong>。</li></ul><p>返回所有可能分配完成后，剩余未放置的水果种类的数量。</p><p><strong>示例 1</strong></p><p><strong>输入：</strong> fruits = [4,2,5], baskets = [3,5,4]</p><p><strong>输出：</strong> 1</p><p><strong>解释：</strong></p><ul><li><code>fruits[0] = 4</code> 放入 <code>baskets[1] = 5</code>。</li><li><code>fruits[1] = 2</code> 放入 <code>baskets[0] = 3</code>。</li><li><code>fruits[2] = 5</code> 无法放入 <code>baskets[2] = 4</code>。</li></ul><p>由于有一种水果未放置，我们返回 1。</p><p><strong>示例 2</strong></p><p><strong>输入：</strong> fruits = [3,6,1], baskets = [6,4,7]</p><p><strong>输出：</strong> 0</p><p><strong>解释：</strong></p><ul><li><code>fruits[0] = 3</code> 放入 <code>baskets[0] = 6</code>。</li><li><code>fruits[1] = 6</code> 无法放入 <code>baskets[1] = 4</code>（容量不足），但可以放入下一个可用的篮子 <code>baskets[2] = 7</code>。</li><li><code>fruits[2] = 1</code> 放入 <code>baskets[1] = 4</code>。</li></ul><p>由于所有水果都已成功放置，我们返回 0。</p><p><strong>提示：</strong></p><ul><li><code>n == fruits.length == baskets.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= fruits[i], baskets[i] &lt;= 1000</code></li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>数据范围比较小，直接模拟即可。</p><p>两个数组都是正整数。遍历fruits数组，每次遍历baskets数组，找到合适的就置0，后续就不会被再次找到。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    int numOfUnplacedFruits(vector&lt;int&gt;&amp; fruits, vector&lt;int&gt;&amp; baskets) {</span>
<span class="line">        int count=0;</span>
<span class="line">        int n=baskets.size();</span>
<span class="line">        for(auto fruit:fruits){</span>
<span class="line">            int unset=1;</span>
<span class="line">            for(int i=0;i&lt;n;i++){</span>
<span class="line">                if(fruit&lt;=baskets[i]){</span>
<span class="line">                    baskets[i]=0;</span>
<span class="line">                    unset=0;</span>
<span class="line">                    break;</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">            count+=unset;</span>
<span class="line">        }</span>
<span class="line">        return count;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><p>时间复杂度：O(n²).</p><p>空间复杂度：O(1)。</p>`,26)]))}const r=e(a,[["render",l]]),d=JSON.parse('{"path":"/leetcode/20250805.html","title":"3477. 水果成篮 II","lang":"zh-CN","frontmatter":{"date":"2025-08-05T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["哈希表","数组","滑动窗口"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"fe0e3caa767126240897b6aae25bcdfbb072cc45","time":1754355094000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250805.md","excerpt":"\\n<p>给你两个长度为 <code>n</code> 的整数数组，<code>fruits</code> 和 <code>baskets</code>，其中 <code>fruits[i]</code> 表示第 <code>i</code> 种水果的 <strong>数量</strong>，<code>baskets[j]</code> 表示第 <code>j</code> 个篮子的 <strong>容量</strong>。</p>\\n<p>你需要对 <code>fruits</code> 数组从左到右按照以下规则放置水果：</p>\\n<ul>\\n<li>每种水果必须放入第一个 <strong>容量大于等于</strong> 该水果数量的 <strong>最左侧可用篮子</strong> 中。</li>\\n<li>每个篮子只能装 <strong>一种</strong> 水果。</li>\\n<li>如果一种水果 <strong>无法放入</strong> 任何篮子，它将保持 <strong>未放置</strong>。</li>\\n</ul>"}');export{r as comp,d as data};
