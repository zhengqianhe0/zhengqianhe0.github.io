import{_ as n,c as i,a as s,o as a}from"./app-CtcNptRb.js";const d={};function l(r,e){return a(),i("div",null,e[0]||(e[0]=[s(`<h1 id="_2683-相邻值的按位异或" tabindex="-1"><a class="header-anchor" href="#_2683-相邻值的按位异或"><span><a href="https://leetcode.cn/problems/neighboring-bitwise-xor/" target="_blank" rel="noopener noreferrer">2683. 相邻值的按位异或</a></span></a></h1><p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 **按位异或（⊕）**派生而来。</p><p>特别地，对于范围 <code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p><ul><li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li><li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li></ul><p>给你一个数组 <code>derived</code> ，请判断是否存在一个能够派生得到 <code>derived</code> 的 <strong>有效原始二进制数组</strong> <code>original</code> 。</p><p>如果存在满足要求的原始二进制数组，返回 <em><strong>true</strong></em> ；否则，返回 <em><strong>false</strong></em> 。</p><ul><li>二进制数组是仅由 <strong>0</strong> 和 <strong>1</strong> 组成的数组。</li></ul><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：derived = [1,1,0]</span>
<span class="line">输出：true</span>
<span class="line">解释：能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：</span>
<span class="line">derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 </span>
<span class="line">derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1</span>
<span class="line">derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：derived = [1,1]</span>
<span class="line">输出：true</span>
<span class="line">解释：能够派生得到 [1,1] 的有效原始二进制数组是 [0,1] ：</span>
<span class="line">derived[0] = original[0] ⊕ original[1] = 1</span>
<span class="line">derived[1] = original[1] ⊕ original[0] = 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">输入：derived = [1,0]</span>
<span class="line">输出：false</span>
<span class="line">解释：不存在能够派生得到 [1,0] 的有效原始二进制数组。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>n == derived.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>derived</code> 中的值不是 <strong>0</strong> 就是 <strong>1</strong> 。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>derived数组生成过程的特点：所有original元素都要参与两次异或计算</p><p>对derived数组求异或和，等价于对original求两次异或和。因此能够正常求出的derived数组，其异或和必为0。</p><p>因此，使用accumulate方法对数组求异或和即可。</p><p>补充分析：异或和等于0 与 和是偶数是否等价？都等价于数组中有偶数个1</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，遍历数组一遍。</li><li>空间复杂度：<em>O</em>(1)。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    bool doesValidArrayExist(vector&lt;int&gt;&amp; derived) {</span>
<span class="line">        return accumulate(derived.begin(), derived.end(), 0, bit_xor&lt;int&gt;()) == 0;</span>
<span class="line">        // return accumulate(derived.begin(), derived.end(), 0) % 2 == 0;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,23)]))}const c=n(d,[["render",l]]),t=JSON.parse('{"path":"/leetcode/20250731.html","title":"2683. 相邻值的按位异或","lang":"zh-CN","frontmatter":{"date":"2025-07-31T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["位运算","数组","数学"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"b9da56d26ae1891b40f19057f1eec26cb235633a","time":1753941665000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250731.md","excerpt":"\\n<p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 **按位异或（⊕）**派生而来。</p>\\n<p>特别地，对于范围 <code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p>\\n<ul>\\n<li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li>\\n<li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li>\\n</ul>"}');export{c as comp,t as data};
