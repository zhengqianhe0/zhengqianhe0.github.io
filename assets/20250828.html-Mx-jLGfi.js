import{_ as s,c as e,a as i,o as l}from"./app-Bpj5Mkzv.js";const a={};function t(r,n){return l(),e("div",null,n[0]||(n[0]=[i(`<h1 id="_3446-按对角线进行矩阵排序" tabindex="-1"><a class="header-anchor" href="#_3446-按对角线进行矩阵排序"><span><a href="https://leetcode.cn/problems/sort-matrix-by-diagonals/" target="_blank" rel="noopener noreferrer">3446. 按对角线进行矩阵排序</a></span></a></h1><p>给你一个大小为 <code>n x n</code> 的整数方阵 <code>grid</code>。返回一个经过如下调整的矩阵：</p><ul><li><strong>左下角三角形</strong>（包括中间对角线）的对角线按 <strong>非递增顺序</strong> 排序。</li><li><strong>右上角三角形</strong> 的对角线按 <strong>非递减顺序</strong> 排序。</li></ul><p><strong>示例 1：</strong></p><p><strong>输入：</strong> grid = [[1,7,3],[9,8,2],[4,5,6]]</p><p><strong>输出：</strong> [[8,2,3],[9,6,7],[4,5,1]]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/12/29/4052example1drawio.png" alt="img"></p><p>标有黑色箭头的对角线（左下角三角形）应按非递增顺序排序：</p><ul><li><code>[1, 8, 6]</code> 变为 <code>[8, 6, 1]</code>。</li><li><code>[9, 5]</code> 和 <code>[4]</code> 保持不变。</li></ul><p>标有蓝色箭头的对角线（右上角三角形）应按非递减顺序排序：</p><ul><li><code>[7, 2]</code> 变为 <code>[2, 7]</code>。</li><li><code>[3]</code> 保持不变。</li></ul><p><strong>示例 2：</strong></p><p><strong>输入：</strong> grid = [[0,1],[1,2]]</p><p><strong>输出：</strong> [[2,1],[1,0]]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/12/29/4052example2adrawio.png" alt="img"></p><p>标有黑色箭头的对角线必须按非递增顺序排序，因此 <code>[0, 2]</code> 变为 <code>[2, 0]</code>。其他对角线已经符合要求。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> grid = [[1]]</p><p><strong>输出：</strong> [[1]]</p><p><strong>解释：</strong></p><p>只有一个元素的对角线已经符合要求，因此无需修改。</p><p><strong>提示：</strong></p><ul><li><code>grid.length == grid[i].length == n</code></li><li><code>1 &lt;= n &lt;= 10</code></li><li><code>-105 &lt;= grid[i][j] &lt;= 105</code></li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>模拟。分别取左下三角与右上三角，逐一按要求重新排序。</p><p>注意循环结束条件：i和j一个代表起始行或列，另一个代表循环次数，即该对角线长度。因此到达边缘时i+j=n-1.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    vector&lt;vector&lt;int&gt;&gt; sortMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</span>
<span class="line">        int n=grid.size();</span>
<span class="line">        for(int i=0;i&lt;n;i++){</span>
<span class="line">            vector&lt;int&gt; tmp;</span>
<span class="line">            for(int j=0;i+j&lt;n;j++){</span>
<span class="line">                tmp.push_back(grid[i+j][j]);</span>
<span class="line">            }</span>
<span class="line">            sort(tmp.begin(),tmp.end(),greater&lt;int&gt;());</span>
<span class="line">            for(int j=0;i+j&lt;n;j++){</span>
<span class="line">                grid[i+j][j]=tmp[j];</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        for(int j=1;j&lt;n;j++){</span>
<span class="line">            vector&lt;int&gt; tmp;</span>
<span class="line">            for(int i=0;j+i&lt;n;i++){</span>
<span class="line">                tmp.push_back(grid[i][j+i]);</span>
<span class="line">            }</span>
<span class="line">            sort(tmp.begin(),tmp.end());</span>
<span class="line">            for(int i=0;j+i&lt;n;i++){</span>
<span class="line">                grid[i][j+i]=tmp[i];</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return grid;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n^2logn) 以矩形宽度n遍历两次，排序算法复杂度nlogn</li><li>空间复杂度：O(n)</li></ul>`,31)]))}const d=s(a,[["render",t]]),o=JSON.parse('{"path":"/leetcode/20250828.html","title":"3446. 按对角线进行矩阵排序","lang":"zh-CN","frontmatter":{"date":"2025-08-28T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","矩阵","排序"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"29e25db4c587a9b02ea530873ddc970aae781c84","time":1756354554000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250828.md","excerpt":"\\n<p>给你一个大小为 <code>n x n</code> 的整数方阵 <code>grid</code>。返回一个经过如下调整的矩阵：</p>\\n<ul>\\n<li><strong>左下角三角形</strong>（包括中间对角线）的对角线按 <strong>非递增顺序</strong> 排序。</li>\\n<li><strong>右上角三角形</strong> 的对角线按 <strong>非递减顺序</strong> 排序。</li>\\n</ul>\\n<p><strong>示例 1：</strong></p>\\n<p><strong>输入：</strong> grid = [[1,7,3],[9,8,2],[4,5,6]]</p>"}');export{d as comp,o as data};
