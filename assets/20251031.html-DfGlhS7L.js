import{_ as s,c as e,a as t,o as a}from"./app-Bpj5Mkzv.js";const i={};function l(r,n){return a(),e("div",null,n[0]||(n[0]=[t(`<h1 id="_3289-数字小镇中的捣蛋鬼" tabindex="-1"><a class="header-anchor" href="#_3289-数字小镇中的捣蛋鬼"><span><a href="https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/" target="_blank" rel="noopener noreferrer">3289. 数字小镇中的捣蛋鬼</a></span></a></h1><p>数字小镇 Digitville 中，存在一个数字列表 <code>nums</code>，其中包含从 <code>0</code> 到 <code>n - 1</code> 的整数。每个数字本应 <strong>只出现一次</strong>，然而，有 <strong>两个</strong> 顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。</p><p>为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。</p><p>返回一个长度为 2 的数组，包含这两个数字（顺序任意）。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong> nums = [0,1,1,0]</p><p><strong>输出：</strong> [0,1]</p><p><strong>解释：</strong></p><p>数字 0 和 1 分别在数组中出现了两次。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong> nums = [0,3,2,1,3,2]</p><p><strong>输出：</strong> [2,3]</p><p><strong>解释:</strong></p><p>数字 2 和 3 分别在数组中出现了两次。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> nums = [7,1,5,4,3,4,6,0,9,5,8,2]</p><p><strong>输出：</strong> [4,5]</p><p><strong>解释:</strong></p><p>数字 4 和 5 分别在数组中出现了两次。</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>nums.length == n + 2</code></li><li><code>0 &lt;= nums[i] &lt; n</code></li><li>输入保证 <code>nums</code> 中 <strong>恰好</strong> 包含两个重复的元素。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>哈希记录数字出现次数</p><p>另外，通过位运算法和数学法，可以压缩空间复杂度</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    vector&lt;int&gt; getSneakyNumbers(vector&lt;int&gt;&amp; nums) {</span>
<span class="line">        vector&lt;int&gt; res;</span>
<span class="line">        unordered_map&lt;int, int&gt; count;</span>
<span class="line">        for (int x : nums) {</span>
<span class="line">            count[x]++;</span>
<span class="line">            if (count[x] == 2) {</span>
<span class="line">                res.push_back(x);</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return res;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>`,27)]))}const p=s(i,[["render",l]]),c=JSON.parse('{"path":"/leetcode/20251031.html","title":"3289. 数字小镇中的捣蛋鬼","lang":"zh-CN","frontmatter":{"date":"2025-10-31T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","哈希表"]},"headers":[],"git":{"updatedTime":1763518154000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":1,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"4b5123a2226ab3055587cb87c78becf08ce40201","time":1763518154000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20251031.md","excerpt":"\\n<p>数字小镇 Digitville 中，存在一个数字列表 <code>nums</code>，其中包含从 <code>0</code> 到 <code>n - 1</code> 的整数。每个数字本应 <strong>只出现一次</strong>，然而，有 <strong>两个</strong> 顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。</p>\\n<p>为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。</p>\\n<p>返回一个长度为 2 的数组，包含这两个数字（顺序任意）。</p>\\n<p><strong>示例 1：</strong></p>"}');export{p as comp,c as data};
