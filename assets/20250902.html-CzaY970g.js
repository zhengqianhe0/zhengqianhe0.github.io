import{_ as e,c as s,a as i,o as a}from"./app-Bpj5Mkzv.js";const l={};function o(p,n){return a(),s("div",null,n[0]||(n[0]=[i(`<h1 id="_3025-人员站位的方案数-i" tabindex="-1"><a class="header-anchor" href="#_3025-人员站位的方案数-i"><span><a href="https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/" target="_blank" rel="noopener noreferrer">3025. 人员站位的方案数 I</a></span></a></h1><p>给你一个 <code>n x 2</code> 的二维数组 <code>points</code> ，它表示二维平面上的一些点坐标，其中 <code>points[i] = [xi, yi]</code> 。</p><p>计算点对 <code>(A, B)</code> 的数量，其中</p><ul><li><code>A</code> 在 <code>B</code> 的左上角，并且</li><li>它们形成的长方形中（或直线上）没有其它点（<strong>包括边界</strong>）。</li></ul><p>返回数量。</p><p><strong>示例 1：</strong></p><p>**输入：**points = [[1,1],[2,2],[3,3]]</p><p>**输出：**0</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png" alt="img"></p><p>没有办法选择 <code>A</code> 和 <code>B</code>，使得 <code>A</code> 在 <code>B</code> 的左上角。</p><p><strong>示例 2：</strong></p><p>**输入：**points = [[6,2],[4,4],[2,6]]</p><p>**输出：**2</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/06/25/t2.jpg" alt="img"></p><ul><li>左边的是点对 <code>(points[1], points[0])</code>，其中 <code>points[1]</code> 在 <code>points[0]</code> 的左上角，并且形成的长方形内部是空的。</li><li>中间的是点对 <code>(points[2], points[1])</code>，和左边的一样是合法的点对。</li><li>右边的是点对 <code>(points[2], points[0])</code>，其中 <code>points[2]</code> 在 <code>points[0]</code> 的左上角，但 <code>points[1]</code> 在长方形内部，所以不是一个合法的点对。</li></ul><p><strong>示例 3：</strong></p><p>**输入：**points = [[3,1],[1,3],[1,1]]</p><p>**输出：**2</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/06/25/t3.jpg" alt="img"></p><ul><li>左边的是点对 <code>(points[2], points[0])</code>，其中 <code>points[2]</code> 在 <code>points[0]</code> 的左上角并且在它们形成的直线上没有其它点。注意两个点形成一条线的情况是合法的。</li><li>中间的是点对 <code>(points[1], points[2])</code>，和左边一样也是合法的点对。</li><li>右边的是点对 <code>(points[1], points[0])</code>，它不是合法的点对，因为 <code>points[2]</code> 在长方形的边上。</li></ul><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 50</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= points[i][0], points[i][1] &lt;= 50</code></li><li><code>points[i]</code> 点对两两不同。</li></ul><h1 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h1><p>学习自定义sort比较函数的写法，第三位是一个lambda函数，接受bool类型的返回值。默认升序a&lt;b，a排在前面。</p><p>先按照x从小到大排序，x相同时，y更大的排在前面。</p><p>外层遍历矩形的左上角。</p><p>符合要求的右下角：y坐标要小于等于左上角，且要大于当前已经遇到过的所有点的y值。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">class Solution {</span>
<span class="line">public:</span>
<span class="line">    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {</span>
<span class="line">        sort(points.begin(),points.end(),[](const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b){</span>
<span class="line">            return a[0]&lt;b[0]||(a[0]==b[0]&amp;&amp;a[1]&gt;b[1]);</span>
<span class="line">        });</span>
<span class="line">        int n=points.size();</span>
<span class="line">        int ans=0;</span>
<span class="line">        for(int i=0;i&lt;n;i++){</span>
<span class="line">            int y1=points[i][1];</span>
<span class="line">            int max_y=INT_MIN;</span>
<span class="line">            for(int j=i+1;j&lt;n;j++){</span>
<span class="line">                int y2=points[j][1];</span>
<span class="line">                if(y2&gt;max_y&amp;&amp;y2&lt;=y1){</span>
<span class="line">                    max_y=y2;</span>
<span class="line">                    ans++;</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        return ans;</span>
<span class="line">    }</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul>`,33)]))}const c=e(l,[["render",o]]),d=JSON.parse('{"path":"/leetcode/20250902.html","title":"3025. 人员站位的方案数 I","lang":"zh-CN","frontmatter":{"date":"2025-09-02T00:00:00.000Z","category":["LeetCode每日一题"],"tag":["数组","数学","排序"]},"headers":[],"git":{"updatedTime":1757033208000,"contributors":[{"name":"zhengqianhe0","username":"zhengqianhe0","email":"1821984431@qq.com","commits":2,"url":"https://github.com/zhengqianhe0"}],"changelog":[{"hash":"74ad287b3313cc2928def8d57bf83e6110f9aa4d","time":1757033208000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"整理分类"},{"hash":"3a00fb429ad9e87a9503ae60ccb5f9b79bb7c925","time":1756777138000,"email":"1821984431@qq.com","author":"zhengqianhe0","message":"mryt"}]},"filePathRelative":"leetcode/20250902.md","excerpt":"\\n<p>给你一个 <code>n x 2</code> 的二维数组 <code>points</code> ，它表示二维平面上的一些点坐标，其中 <code>points[i] = [xi, yi]</code> 。</p>\\n<p>计算点对 <code>(A, B)</code> 的数量，其中</p>\\n<ul>\\n<li><code>A</code> 在 <code>B</code> 的左上角，并且</li>\\n<li>它们形成的长方形中（或直线上）没有其它点（<strong>包括边界</strong>）。</li>\\n</ul>\\n<p>返回数量。</p>\\n<p><strong>示例 1：</strong></p>"}');export{c as comp,d as data};
