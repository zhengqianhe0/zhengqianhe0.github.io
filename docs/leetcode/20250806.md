---
date: 2025-08-06
category:
  - 简单
tag:
  - 哈希表
  - 数组
  - 滑动窗口
---

# [3477. 水果成篮 II](https://leetcode.cn/problems/fruits-into-baskets-ii/)

给你两个长度为 `n` 的整数数组，`fruits` 和 `baskets`，其中 `fruits[i]` 表示第 `i` 种水果的 **数量**，`baskets[j]` 表示第 `j` 个篮子的 **容量**。

你需要对 `fruits` 数组从左到右按照以下规则放置水果：

- 每种水果必须放入第一个 **容量大于等于** 该水果数量的 **最左侧可用篮子** 中。
- 每个篮子只能装 **一种** 水果。
- 如果一种水果 **无法放入** 任何篮子，它将保持 **未放置**。

返回所有可能分配完成后，剩余未放置的水果种类的数量。

 

**示例 1**

**输入：** fruits = [4,2,5], baskets = [3,5,4]

**输出：** 1

**解释：**

- `fruits[0] = 4` 放入 `baskets[1] = 5`。
- `fruits[1] = 2` 放入 `baskets[0] = 3`。
- `fruits[2] = 5` 无法放入 `baskets[2] = 4`。

由于有一种水果未放置，我们返回 1。

**示例 2**

**输入：** fruits = [3,6,1], baskets = [6,4,7]

**输出：** 0

**解释：**

- `fruits[0] = 3` 放入 `baskets[0] = 6`。
- `fruits[1] = 6` 无法放入 `baskets[1] = 4`（容量不足），但可以放入下一个可用的篮子 `baskets[2] = 7`。
- `fruits[2] = 1` 放入 `baskets[1] = 4`。

由于所有水果都已成功放置，我们返回 0。

 

**提示：**

- `n == fruits.length == baskets.length`
- `1 <= n <= 105`
- `1 <= fruits[i], baskets[i] <= 109`
- **相比于昨天的题目，数据变大，n²的时间复杂度会超时**

# 解题思路

关键在于**高效查找第一个可用篮子**：

1. 对于每个水果，需要找到第一个容量≥该水果数量的篮子
2. 找到后该篮子就被占用（容量设为-1）
3. 统计找不到合适篮子的水果数量



两个数组都是正整数。遍历fruits数组，每次遍历baskets数组，找到合适的就置0，后续就不会被再次找到。

```
class SegmentTree{
	// 存储节点区间最大值
    vector<int> mx;、
    // 维护线段树：更新父节点的值为两个子节点的最大值
    void maintain(int o){
        mx[o]=max(mx[o*2],mx[o*2+1]);
    }
    void build(const vector<int>&a,int o,int l,int r){
        if(l==r){
            mx[o]=a[l];
            return;
        }
        int m=(l+r)/2;
        build(a,o*2,l,m);
        build(a,o*2+1,m+1,r);
        maintain(o);
    }
public:
	// bit_width(n-1) 计算n-1的二进制位数
	// 2<<bit_width(n-1) 确保空间足够，通常是4n大小
    SegmentTree(const vector<int>& a){
        size_t n=a.size();
        mx.resize(2<<bit_width(n-1));
        // 根节点是编号1
        build(a,1,0,n-1);
    }
    int findFirstAndUpdate(int o,int l,int r,int x){
        if(mx[o]<x){
            return -1;
        }
        if(l==r){
            mx[o]=-1;
            return l;
        }
        int m=(l+r)/2;
        int i=findFirstAndUpdate(o*2,l,m,x);
        if(i<0){
            i=findFirstAndUpdate(o*2+1,m+1,r,x);
        }
        maintain(o);
        return i;
    }
};

class Solution {
public:
    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        SegmentTree t(baskets);
        int n=baskets.size(),ans=0;
        for(int x:fruits){
            if(t.findFirstAndUpdate(1,0,n-1,x)<0){
                ans++;
            }
        }
        return ans;
    }
};
```



复杂度分析

时间复杂度：O(n²).

空间复杂度：O(1)。
