---
date: 2025-08-27
category:
  - LeetCode每日一题
tag:
  - 数组
  - 记忆化搜索
  - 动态规划
---

# [3459. 最长 V 形对角线段的长度](https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/)

给你一个大小为 `n x m` 的二维整数矩阵 `grid`，其中每个元素的值为 `0`、`1` 或 `2`。

**V 形对角线段** 定义如下：

- 线段从 `1` 开始。
- 后续元素按照以下无限序列的模式排列：`2, 0, 2, 0, ...`。
- 该线段：
  - 起始于某个对角方向（左上到右下、右下到左上、右上到左下或左下到右上）。
  - 沿着相同的对角方向继续，保持 **序列模式** 。
  - 在保持 **序列模式** 的前提下，最多允许 **一次顺时针 90 度转向** 另一个对角方向。

![img](https://pic.leetcode.cn/1739609732-jHpPma-length_of_longest3.jpg)

返回最长的 **V 形对角线段** 的 **长度** 。如果不存在有效的线段，则返回 0。

 

**示例 1：**

**输入：** grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]

**输出：** 5

**解释：**

![img](https://pic.leetcode.cn/1739609768-rhePxN-matrix_1-2.jpg)

最长的 V 形对角线段长度为 5，路径如下：`(0,2) → (1,3) → (2,4)`，在 `(2,4)` 处进行 **顺时针 90 度转向** ，继续路径为 `(3,3) → (4,2)`。

**示例 2：**

**输入：** grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]

**输出：** 4

**解释：**

![img](https://pic.leetcode.cn/1739609774-nYJElV-matrix_2.jpg)

最长的 V 形对角线段长度为 4，路径如下：`(2,3) → (3,2)`，在 `(3,2)` 处进行 **顺时针 90 度转向** ，继续路径为 `(2,1) → (1,0)`。

**示例 3：**

**输入：** grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]

**输出：** 5

**解释：**

![img](https://pic.leetcode.cn/1739609780-tlkdUW-matrix_3.jpg)

最长的 V 形对角线段长度为 5，路径如下：`(0,0) → (1,1) → (2,2) → (3,3) → (4,4)`。

**示例 4：**

**输入：** grid = [[1]]

**输出：** 1

**解释：**

最长的 V 形对角线段长度为 1，路径如下：`(0,0)`。

 

**提示：**

- `n == grid.length`
- `m == grid[i].length`
- `1 <= n, m <= 500`
- `grid[i][j]` 的值为 `0`、`1` 或 `2`。

# 解题思路

这段代码用于求解二维网格中 "最长 V 形对角线片段" 的长度。V 形片段的定义是：以值为 1 的单元格为起点，沿对角线方向延伸，由 1 和 2 交替组成，且最多允许一次顺时针 90° 转向（形成 "V" 字形状）。

### 核心逻辑分析

1. **方向定义**：`dirs`数组定义了 4 个对角线方向：`{1,1}`（右下）、`{1,-1}`（左下）、`{-1,-1}`（左上）、`{-1,1}`（右上）。
2. **记忆化存储**：`memo`是一个四维数组`[m][n][4][2]`，用于缓存计算结果，避免重复递归：
   - 前两维：当前坐标`(nx, ny)`
   - 第三维：当前移动方向（0-3）
   - 第四维：是否允许转向（`true`/`false`，对应 1/0）
3. **DFS 递归函数**：通过深度优先搜索计算最长 V 形片段：
   - 计算下一个坐标`(nx, ny)`，若越界或值不等于目标值（1 和 2 交替），返回 0
   - 若`memo`中已有缓存结果，直接返回
   - 否则递归计算：
     - 沿原方向继续延伸（目标值切换为`2 - target`，实现 1 和 2 交替）
     - 若允许转向（`turn=true`），尝试顺时针转 90°（方向`(direction+1)%4`）并禁止再次转向
   - 缓存结果并返回（当前步长 + 1）
4. **主循环**：遍历所有值为 1 的单元格，从 4 个方向开始 DFS，更新最长片段长度。

### 时间复杂度分析

- **状态总数**：`memo`数组的大小为`m × n × 4 × 2`（网格大小 ×4 个方向 ×2 种转向状态）
- **每个状态计算**：每个状态仅计算一次，每次递归操作是 O (1)
- **总复杂度**：O (m・n)（4 和 2 是常数，可忽略）

### 空间复杂度分析

- **记忆化数组**：`memo`占用 O (m・n・4・2) = O (m・n) 空间
- **递归栈深度**：最坏情况下递归深度为 O (m・n)（沿对角线遍历整个网格）
- **总复杂度**：O(m·n)

```
class Solution {
private:
    int dfs(int cx, int cy, int direction, bool turn, int target,
            const vector<vector<int>>& grid, const int dirs[4][2],
            int memo[505][505][4][2]) {
        int m = grid.size();
        int n = grid[0].size();
        int nx = cx + dirs[direction][0];
        int ny = cy + dirs[direction][1];
        
        if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] != target) {
            return 0;
        }
        
        if (memo[nx][ny][direction][turn] != -1) {
            return memo[nx][ny][direction][turn];
        }
        
        int maxStep = dfs(nx, ny, direction, turn, 2 - target, grid, dirs, memo);
        if (turn) {
            maxStep = max(maxStep,
                          dfs(nx, ny, (direction + 1) % 4, false, 2 - target, grid, dirs, memo));
        }
        
        memo[nx][ny][direction][turn] = maxStep + 1;
        return maxStep + 1;
    }

public:
    inline int lenOfVDiagonal(vector<vector<int>>& grid) {
        int m = grid.size();
        if (m == 0) return 0;
        int n = grid[0].size();
        int dirs[4][2] = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};
        // 静态创建数组
        static int memo[505][505][4][2];
        memset(memo, -1, sizeof(memo));
        
        int res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    for (int direction = 0; direction < 4; ++direction) {
                        res = max(res, dfs(i, j, direction, true, 2, grid, dirs, memo) + 1);
                    }
                }
            }
        }
        return res;
    }
};

```

复杂度分析

- 时间复杂度：O(mn)
- 空间复杂度：O(mn)

  
