---
date: 2025-10-05
category:
  - LeetCode每日一题
tag:
  - 矩阵
  - 数组
  - DFS
  - BFS
---

# [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。

岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例 2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

 

**提示：**

- `m == heights.length`
- `n == heights[r].length`
- `1 <= m, n <= 200`
- `0 <= heights[r][c] <= 105`

# 解题思路

学习lambda递归的写法

vis数组用int8_t类型的意义：

仅占一字节，bool不能取地址，比bool计算快，比int节省空间

```
class Solution {
    // 左右上下
    static constexpr int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size(), n = heights[0].size();

        // lambda 递归
        auto dfs = [&](this auto&& dfs, int i, int j, vector<vector<int8_t>>& vis) -> void {
            if (vis[i][j]) { // 避免重复访问，避免反复横跳无限递归
                return;
            }
            vis[i][j] = true; // 标记 (i,j) 已访问
            for (auto& [dx, dy] : DIRS) { // 枚举相邻格子
                int x = i + dx, y = j + dy;
                if (0 <= x && x < m && 0 <= y && y < n && heights[x][y] >= heights[i][j]) { // 往高处走
                    dfs(x, y, vis);
                }
            }
        };

        // 从太平洋边界出发
        vector pacific_vis(m, vector<int8_t>(n));
        for (int j = 0; j < n; j++) {
            dfs(0, j, pacific_vis); // 上边界
        }
        for (int i = 1; i < m; i++) {
            dfs(i, 0, pacific_vis); // 左边界
        }

        // 从大西洋边界出发
        vector atlantic_vis(m, vector<int8_t>(n));
        for (int j = 0; j < n; j++) {
            dfs(m - 1, j, atlantic_vis); // 下边界
        }
        for (int i = 0; i < m - 1; i++) {
            dfs(i, n - 1, atlantic_vis); // 右边界
        }

        // 交集即为答案
        vector<vector<int>> ans;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific_vis[i][j] && atlantic_vis[i][j]) {
                    ans.push_back({i, j});
                }
            }
        }
        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(mn)
- 空间复杂度：O(mn)
