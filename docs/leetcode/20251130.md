---
date: 2025-11-30
category:
  - LeetCode每日一题
tag:
  - 数学
  - 数组
  - 哈希表
  - 前缀和
---

# [1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/)

给你一个正整数数组 `nums`，请你移除 **最短** 子数组（可以为 **空**），使得剩余元素的 **和** 能被 `p` 整除。 **不允许** 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 `-1` 。

**子数组** 定义为原数组中连续的一组元素。

 

**示例 1：**

```
输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
```

**示例 2：**

```
输入：nums = [6,3,5,2], p = 9
输出：2
解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。
```

**示例 3：**

```
输入：nums = [1,2,3], p = 3
输出：0
解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。
```

**示例 4：**

```
输入：nums = [1,2,3], p = 7
输出：-1
解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。
```

**示例 5：**

```
输入：nums = [1000000000,1000000000,1000000000], p = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= p <= 109`

# 解题思路

建立前缀和数组，记录余数。先判断综合是否能整除。

用哈希表记录相同余数出现的上一次位置（两个余数相同的相减表示子数组和能被整除）

我们不是要找余数差为 0 的子数组，而是要找余数差等于总余数 `x` 的子数组。所以，当我们走到当前位置时，就去哈希表里查：“有没有哪个之前的余数，加上 `x` 之后刚好等于我现在的余数？”——换句话说，就是找那个能让中间这段子数组“补上”总余数的起点。

一旦找到了，就用当前位置减去那个起点位置，得到子数组长度，并不断更新最短长度。

最后，如果最短长度等于整个数组的长度，说明只有把全部元素都删掉才行，但题目不允许这样（因为删光了就没有“剩余元素”了），所以返回 -1；否则就返回找到的最短长度。

```
class Solution {
public:
    int minSubarray(vector<int> &nums, int p) {
        int n = nums.size(), s[n + 1];
        s[0] = 0;
        for (int i = 0; i < n; i++) {
            s[i + 1] = (s[i] + nums[i]) % p;
        }
        int x = s[n];
        if (x == 0) {
            return 0; // 移除空子数组（这行可以不要）
        }

        int ans = n;
        unordered_map<int, int> last;
        for (int i = 0; i <= n; ++i) {
            last[s[i]] = i;
            auto it = last.find((s[i] - x + p) % p);
            if (it != last.end()) {
                ans = min(ans, i - it->second);
            }
        }
        return ans < n ? ans : -1;
    }
};
```

复杂度分析


- 时间复杂度：O(n)
- 空间复杂度：O(n)

