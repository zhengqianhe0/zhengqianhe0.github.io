---
date: 2025-09-14
category:
  - LeetCode每日一题
tag:
  - 字符串
  - 哈希表
  - 数组
---

# [966. 元音拼写检查器](https://leetcode.cn/problems/vowel-spellchecker/)

在给定单词列表 `wordlist` 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。

对于给定的查询单词 `query`，拼写检查器将会处理两类拼写错误：

- 大小写：如果查询匹配单词列表中的某个单词（

  不区分大小写

  ），则返回的正确单词与单词列表中的大小写相同。

  - 例如：`wordlist = ["yellow"]`, `query = "YellOw"`: `correct = "yellow"`
  - 例如：`wordlist = ["Yellow"]`, `query = "yellow"`: `correct = "Yellow"`
  - 例如：`wordlist = ["yellow"]`, `query = "yellow"`: `correct = "yellow"`

- 元音错误：如果在将查询单词中的元音

   

  ```
  ('a', 'e', 'i', 'o', 'u')
  ```

   分别替换为任何元音后，能与单词列表中的单词匹配（

  不区分大小写

  ），则返回的正确单词与单词列表中的匹配项大小写相同。

  - 例如：`wordlist = ["YellOw"]`, `query = "yollow"`: `correct = "YellOw"`
  - 例如：`wordlist = ["YellOw"]`, `query = "yeellow"`: `correct = ""` （无匹配项）
  - 例如：`wordlist = ["YellOw"]`, `query = "yllw"`: `correct = ""` （无匹配项）

此外，拼写检查器还按照以下优先级规则操作：

- 当查询完全匹配单词列表中的某个单词（**区分大小写**）时，应返回相同的单词。
- 当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
- 当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
- 如果该查询在单词列表中没有匹配项，则应返回空字符串。

给出一些查询 `queries`，返回一个单词列表 `answer`，其中 `answer[i]` 是由查询 `query = queries[i]` 得到的正确单词。

 

**示例 1：**

```
输入：wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
输出：["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]
```

**示例 2:**

```
输入：wordlist = ["yellow"], queries = ["YellOw"]
输出：["yellow"]
```

 

**提示：**

- `1 <= wordlist.length, queries.length <= 5000`
- `1 <= wordlist[i].length, queries[i].length <= 7`
- `wordlist[i]` 和 `queries[i]` 只包含英文字母

# 解题思路


该题解用于解决拼写检查问题，核心思路是通过三级匹配机制处理查询：首先检查精确匹配（完全相同的单词），若不匹配则检查大小写不敏感匹配（忽略大小写差异），若仍不匹配则检查元音不敏感匹配（忽略元音字母的差异）。为实现高效匹配，使用了三个数据结构：集合存储原始单词用于精确匹配，两个哈希表分别存储小写形式和元音替换形式到原始单词的映射，通过预处理单词列表构建这些映射关系，再依次对每个查询应用三级匹配规则，最终返回匹配结果。这种设计确保了查询处理的高效性和匹配规则的优先级顺序。

```
class Solution {
    // 将字符串转换为全小写
    string tolower_string(string s){
        for(char& c:s){
            c=tolower(c); // 逐个字符转为小写
        }
        return s;
    }
    
    // 将字符串中的元音字母(a,e,i,o,u)替换为'?'
    string replace_vowels(string s){
        for(char&c :s){
            // 检查是否为元音字母
            if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'){
                c='?'; // 元音字母替换为'?'
            }
        }
        return s;
    }
    
public:
    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {
        int n=wordlist.size();
        
        // 存储原始单词，用于精确匹配检查
        unordered_set<string> origin(wordlist.begin(),wordlist.end());
        
        // 存储小写形式到原始单词的映射（用于大小写不敏感匹配）
        unordered_map<string,string> lower_to_origin;
        
        // 存储替换元音后的小写形式到原始单词的映射（用于元音不敏感匹配）
        unordered_map<string,string> vowel_to_origin;

        // 从后往前遍历，确保前面的单词覆盖后面的（保留第一个出现的单词）
        for(int i=n-1;i>=0;i--){
            string& s=wordlist[i];
            string lower=tolower_string(s);
            lower_to_origin[lower]=s;  // 存储小写映射
            // 先转小写再替换元音，存储元音替换后的映射
            vowel_to_origin[replace_vowels(lower)]=s;
        }

        // 处理每个查询
        for(string& q:queries){
            // 1. 精确匹配：如果查询词在原始集合中，不做修改
            if(origin.contains(q)){
                continue;
            }
            
            // 2. 大小写不敏感匹配：转换为小写后查找
            string lower=tolower_string(q);
            auto it=lower_to_origin.find(lower);
            if(it!=lower_to_origin.end()){
                q=it->second; // 找到则替换为原始单词
            }else{
                // 3. 元音不敏感匹配：替换元音后查找
                auto it=vowel_to_origin.find(replace_vowels(lower));
                q=it!=vowel_to_origin.end()?it->second:""; // 找到则替换，否则为空
            }
        }
        return queries;
    }
};
```

复杂度分析

- 时间复杂度：O(m+n) 字符串的总数
- 空间复杂度：O(n)
