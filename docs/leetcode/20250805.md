---
date: 2025-08-05
category:
  - 简单
tag:
  - 哈希表
  - 数组
  - 滑动窗口
---

# [3477. 水果成篮 II](https://leetcode.cn/problems/fruits-into-baskets-ii/)

给你两个长度为 `n` 的整数数组，`fruits` 和 `baskets`，其中 `fruits[i]` 表示第 `i` 种水果的 **数量**，`baskets[j]` 表示第 `j` 个篮子的 **容量**。

你需要对 `fruits` 数组从左到右按照以下规则放置水果：

- 每种水果必须放入第一个 **容量大于等于** 该水果数量的 **最左侧可用篮子** 中。
- 每个篮子只能装 **一种** 水果。
- 如果一种水果 **无法放入** 任何篮子，它将保持 **未放置**。

返回所有可能分配完成后，剩余未放置的水果种类的数量。

 

**示例 1**

**输入：** fruits = [4,2,5], baskets = [3,5,4]

**输出：** 1

**解释：**

- `fruits[0] = 4` 放入 `baskets[1] = 5`。
- `fruits[1] = 2` 放入 `baskets[0] = 3`。
- `fruits[2] = 5` 无法放入 `baskets[2] = 4`。

由于有一种水果未放置，我们返回 1。

**示例 2**

**输入：** fruits = [3,6,1], baskets = [6,4,7]

**输出：** 0

**解释：**

- `fruits[0] = 3` 放入 `baskets[0] = 6`。
- `fruits[1] = 6` 无法放入 `baskets[1] = 4`（容量不足），但可以放入下一个可用的篮子 `baskets[2] = 7`。
- `fruits[2] = 1` 放入 `baskets[1] = 4`。

由于所有水果都已成功放置，我们返回 0。

 

**提示：**

- `n == fruits.length == baskets.length`
- `1 <= n <= 100`
- `1 <= fruits[i], baskets[i] <= 1000`

# 解题思路

数据范围比较小，直接模拟即可。

两个数组都是正整数。遍历fruits数组，每次遍历baskets数组，找到合适的就置0，后续就不会被再次找到。

```
class Solution {
public:
    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        int count=0;
        int n=baskets.size();
        for(auto fruit:fruits){
            int unset=1;
            for(int i=0;i<n;i++){
                if(fruit<=baskets[i]){
                    baskets[i]=0;
                    unset=0;
                    break;
                }
            }
            count+=unset;
        }
        return count;
    }
};
```



复杂度分析

时间复杂度：O(n²).

空间复杂度：O(1)。
