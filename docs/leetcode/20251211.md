---
date: 2025-12-11
category:
  - LeetCode每日一题
tag:
  - 数组
  - 哈希表
  - 排序
---

# [3531. 统计被覆盖的建筑](https://leetcode.cn/problems/count-covered-buildings/)

给你一个正整数 `n`，表示一个 `n x n` 的城市，同时给定一个二维数组 `buildings`，其中 `buildings[i] = [x, y]` 表示位于坐标 `[x, y]` 的一个 **唯一** 建筑。

如果一个建筑在四个方向（左、右、上、下）中每个方向上都至少存在一个建筑，则称该建筑 **被覆盖** 。

返回 **被覆盖** 的建筑数量。

 

**示例 1：**

![img](https://pic.leetcode.cn/1745660407-qtNUjI-telegram-cloud-photo-size-5-6212982906394101085-m.jpg)

**输入:** n = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]

**输出:** 1

**解释:**

- 只有建筑

   

  ```
  [2,2]
  ```

   

  被覆盖，因为它在每个方向上都至少存在一个建筑：

  - 上方 (`[1,2]`)
  - 下方 (`[3,2]`)
  - 左方 (`[2,1]`)
  - 右方 (`[2,3]`)

- 因此，被覆盖的建筑数量是 1。

**示例 2：**

![img](https://pic.leetcode.cn/1745660407-tUMUKl-telegram-cloud-photo-size-5-6212982906394101086-m.jpg)

**输入:** n = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]

**输出:** 0

**解释:**

- 没有任何一个建筑在每个方向上都有至少一个建筑。

**示例 3：**

![img](https://pic.leetcode.cn/1745660407-bQIwBX-telegram-cloud-photo-size-5-6248862251436067566-x.jpg)

**输入:** n = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]

**输出:** 1

**解释:**

- 只有建筑

   

  ```
  [3,3]
  ```

   

  被覆盖，因为它在每个方向上至少存在一个建筑：

  - 上方 (`[1,3]`)
  - 下方 (`[5,3]`)
  - 左方 (`[3,2]`)
  - 右方 (`[3,5]`)

- 因此，被覆盖的建筑数量是 1。

 

**提示：**

- `2 <= n <= 105`
- `1 <= buildings.length <= 105`
- `buildings[i] = [x, y]`
- `1 <= x, y <= n`
- `buildings` 中所有坐标均 **唯一** 。

 

# 解题思路

第一次遍历找每一行，每一列的最小值和最大值

第二次遍历判断每个建筑是否满足在最大值和最小值之间

```
class Solution {
public:
    int countCoveredBuildings(int n, vector<vector<int>>& buildings) {
        vector<int> row_min(n + 1, INT_MAX), row_max(n + 1);
        vector<int> col_min(n + 1, INT_MAX), col_max(n + 1);
        for (auto& p : buildings) {
            int x = p[0], y = p[1];
            row_min[y] = min(row_min[y], x);
            row_max[y] = max(row_max[y], x);
            col_min[x] = min(col_min[x], y);
            col_max[x] = max(col_max[x], y);
        }

        int ans = 0;
        for (auto& p : buildings) {
            int x = p[0], y = p[1];
            if (row_min[y] < x && x < row_max[y] && col_min[x] < y && y < col_max[x]) {
                ans++;
            }
        }
        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(n+m)
- 空间复杂度：O(n)

