---
date: 2025-08-21
category:
  - LeetCode每日一题
tag:
  - 数组
  - 动态规划
  - 矩阵
---

# [1504. 统计全 1 子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/)

给你一个 `m x n` 的二进制矩阵 `mat` ，请你返回有多少个 **子矩形** 的元素全部都是 1 。

**示例 1：**

```
输入：mat = [[1,0,1],[1,1,0],[1,1,0]]
输出：13
解释：
有 6 个 1x1 的矩形。
有 2 个 1x2 的矩形。
有 3 个 2x1 的矩形。
有 1 个 2x2 的矩形。
有 1 个 3x1 的矩形。
矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。
```

**示例 2：**

```
输入：mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
输出：24
解释：
有 8 个 1x1 的子矩形。
有 5 个 1x2 的子矩形。
有 2 个 1x3 的子矩形。
有 4 个 2x1 的子矩形。
有 2 个 2x2 的子矩形。
有 2 个 3x1 的子矩形。
有 1 个 3x2 的子矩形。
矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。
```

 **提示：**

- `1 <= m, n <= 150`
- `mat[i][j]` 仅包含 `0` 或 `1`

# 解题思路

单调栈设计相对复杂。基本dp方法是，将二维映射到一维，遍历到第j行时统计当前行及以上每一列的1的个数，按右下角进行遍历。

```
class Solution {
public:
    int numSubmat(vector<vector<int>>& mat) {
        int m=mat.size(),n=mat[0].size();
        int ans=0;
        // 枚举上边界
        for(int top=0;top<m;++top){
            vector<int> a(n);	// 创建计数数组
            // 枚举下边界
            for(int bottom=top;bottom<m;++bottom){
                int h=bottom-top+1;
                int last=-1;
                // 枚举这一行，先计数，只有高度满足h的才计数，相当于在当前数组里找全h的子数组
                for(int j=0;j<n;++j){
                    a[j]+=mat[bottom][j];
                    if(a[j]!=h){
                        last=j;
                    }else{
                        ans+=j-last;
                    }
                }
            }
        }
        return ans;
    }
};
```

复杂度分析

- 时间复杂度：O(m2n)
- 空间复杂度：O(n)

  
