---
date: 2025-08-10
category:
  - 中等
tag:
  - 哈希表
  - 数组
---

# [869. 重新排序得到 2 的幂](https://leetcode.cn/problems/reordered-power-of-2/)

给定正整数 `n` ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 `true`；否则，返回 `false`。

 



**示例 1：**

```
输入：n = 1
输出：true
```

**示例 2：**

```
输入：n = 10
输出：false
```

 

**提示：**

- `1 <= n <= 109`

# 解题思路

数据范围有限，可以打表。

用一个长度为 10 的`string`（`cnt`）存储计数，索引 0-9 分别对应数字 0-9 的出现次数。

用哈希表存粹所有预处理的string，再对目标n进行处理判断是否存在

```
class Solution {
public:
    string countDigits(int n){
        string cnt(10,0);
        while(n){
            ++cnt[n%10];
            n/=10;
        }
        return cnt;
    }
    unordered_set<string> powerOf2Digits;

    bool reorderedPowerOf2(int n) {
        for(int n=1;n<=1e9;n<<=1){
            powerOf2Digits.insert(countDigits(n));
        }
        return powerOf2Digits.count(countDigits(n));
    }
};
```

复杂度分析

- 时间复杂度：O(logn)。统计n中出现过的2的幂需要log次
- 空间复杂度：O(*1*)。

