---
date: 2025-10-02
category:
  - LeetCode每日一题
tag:
  - 数学
  - 模拟
---

# [3100. 换水问题 II](https://leetcode.cn/problems/water-bottles-ii/)

给你两个整数 `numBottles` 和 `numExchange` 。

`numBottles` 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：

- 喝掉任意数量的满水瓶，使它们变成空水瓶。
- 用 `numExchange` 个空水瓶交换一个满水瓶。然后，将 `numExchange` 的值增加 1 。

注意，你不能使用相同的 `numExchange` 值交换多批空水瓶。例如，如果 `numBottles == 3` 并且 `numExchange == 1` ，则不能用 `3` 个空水瓶交换成 `3` 个满水瓶。

返回你 **最多** 可以喝到多少瓶水。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2024/01/28/exampleone1.png)

```
输入：numBottles = 13, numExchange = 6
输出：15
解释：上表显示了满水瓶的数量、空水瓶的数量、numExchange 的值，以及累计喝掉的水瓶数量。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2024/01/28/example231.png)

```
输入：numBottles = 10, numExchange = 3
输出：13
解释：上表显示了满水瓶的数量、空水瓶的数量、numExchange 的值，以及累计喝掉的水瓶数量。
```

 

**提示：**

- `1 <= numBottles <= 100 `
- `1 <= numExchange <= 100`

# 解题思路



```
class Solution {
public:
    int maxBottlesDrunk(int numBottles, int numExchange) {
        int ans=numBottles,empty=numBottles;
        while(empty>=numExchange){
            empty-=numExchange; 
            numExchange++;  // 模拟法，在昨天的基础上加一个交换数会增加
            ans++;
            empty++;
        }
        return ans;
    }
};

// 附：公式法 O(1)
n−((e−1)+e+(e+1)+⋯+(e+k−2))<e+k
k²+(2e−1)k−2(n−e)>0
求根公式求k>x1，根据二次函数特点，要大于x1再加1后取整

class Solution {
public:
    int numWaterBottles(int numBottles, int numExchange) {
        return numBottles + (numBottles - 1) / (numExchange - 1);
    }
};

class Solution {
public:
    int maxBottlesDrunk(int n, int e) {
        int b = e * 2 - 1;
        int k = ((int) sqrt(b * b + (n - e) * 8) - b + 2) / 2;
        return n + k;
    }
};
```

复杂度分析


- 时间复杂度：O(√b)， b会线性增多，求和是n²级，作为循环判断条件对应复杂度为平方根级
- 空间复杂度：O(1)
