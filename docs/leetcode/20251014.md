---
date: 2025-10-14
category:
  - LeetCode每日一题
tag:
  - 数组
---

# [3349. 检测相邻递增子数组 I](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/)

给你一个由 `n` 个整数组成的数组 `nums` 和一个整数 `k`，请你确定是否存在 **两个** **相邻** 且长度为 `k` 的 **严格递增** 子数组。具体来说，需要检查是否存在从下标 `a` 和 `b` (`a < b`) 开始的 **两个** 子数组，并满足下述全部条件：

- 这两个子数组 `nums[a..a + k - 1]` 和 `nums[b..b + k - 1]` 都是 **严格递增** 的。
- 这两个子数组必须是 **相邻的**，即 `b = a + k`。

如果可以找到这样的 **两个** 子数组，请返回 `true`；否则返回 `false`。

**子数组** 是数组中的一个连续 **非空** 的元素序列。

 

**示例 1：**

**输入：**nums = [2,5,7,8,9,2,3,4,3,1], k = 3

**输出：**true

**解释：**

- 从下标 `2` 开始的子数组为 `[7, 8, 9]`，它是严格递增的。
- 从下标 `5` 开始的子数组为 `[2, 3, 4]`，它也是严格递增的。
- 两个子数组是相邻的，因此结果为 `true`。

**示例 2：**

**输入：**nums = [1,2,3,4,4,4,4,5,6,7], k = 5

**输出：**false

 

**提示：**

- `2 <= nums.length <= 100`
- `1 <= 2 * k <= nums.length`
- `-1000 <= nums[i] <= 1000`

 

# 解题思路

找到满足要求的最大的k（两个连续的递增的子数组），判断k是否大于参数要求

```
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();  // 数组长度
        int cnt = 1;          // 当前递增序列的长度
        int precnt = 0;       // 前一个递增序列的长度
        int ans = 0;          // 存储满足条件的最大子数组长度
        
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                cnt++;  // 如果当前元素大于前一个，递增序列长度+1
            } else {
                precnt = cnt;  // 递增序列结束，保存当前长度到precnt
                cnt = 1;       // 重置当前递增序列长度
            }
            
            // 更新可能的最大子数组长度：
            // 1. 取前一个递增序列和当前递增序列的最小值
            // 2. 或者当前递增序列的一半
            ans=max({ans,min(precnt,cnt),cnt/2});
        }
        
        // 判断是否存在长度至少为k的满足条件的子数组
        return ans >= k;
    }
};
```

复杂度分析


- 时间复杂度：O(n)
- 空间复杂度：O(1)
