---
date: 2025-11-04
category:
  - LeetCode每日一题
tag:
  - 滑动窗口
  - 哈希表
  - 数组
---

# [3318. 计算子数组的 x-sum I](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/)

给你一个由 `n` 个整数组成的数组 `nums`，以及两个整数 `k` 和 `x`。

数组的 **x-sum** 计算按照以下步骤进行：

- 统计数组中所有元素的出现次数。
- 仅保留出现次数最多的前 `x` 个元素的每次出现。如果两个元素的出现次数相同，则数值 **较大** 的元素被认为出现次数更多。
- 计算结果数组的和。

**注意**，如果数组中的不同元素少于 `x` 个，则其 **x-sum** 是数组的元素总和。

返回一个长度为 `n - k + 1` 的整数数组 `answer`，其中 `answer[i]` 是 子数组 `nums[i..i + k - 1]` 的 **x-sum**。

**子数组** 是数组内的一个连续 **非空** 的元素序列。

 

**示例 1：**

**输入：**nums = [1,1,2,2,3,4,2,3], k = 6, x = 2

**输出：**[6,10,12]

**解释：**

- 对于子数组 `[1, 1, 2, 2, 3, 4]`，只保留元素 1 和 2。因此，`answer[0] = 1 + 1 + 2 + 2`。
- 对于子数组 `[1, 2, 2, 3, 4, 2]`，只保留元素 2 和 4。因此，`answer[1] = 2 + 2 + 2 + 4`。注意 4 被保留是因为其数值大于出现其他出现次数相同的元素（3 和 1）。
- 对于子数组 `[2, 2, 3, 4, 2, 3]`，只保留元素 2 和 3。因此，`answer[2] = 2 + 2 + 2 + 3 + 3`。

**示例 2：**

**输入：**nums = [3,8,7,8,7,5], k = 2, x = 2

**输出：**[11,15,15,15,12]

**解释：**

由于 `k == x`，`answer[i]` 等于子数组 `nums[i..i + k - 1]` 的总和。

 

**提示：**

- `1 <= n == nums.length <= 50`
- `1 <= nums[i] <= 50`
- `1 <= x <= k <= nums.length`

# 解题思路

确定所有的k个情况，遍历每个情况统计个数。

借助pair进行排序，注意sort函数自定义比较器的写法

```
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer(n - k + 1);
        
        for (int i = 0; i <= n - k; i++) {
            // 统计当前窗口内元素的频率
            unordered_map<int, int> freq;
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }
            
            // 如果不同元素数量少于x，直接计算总和
            if (freq.size() <= x) {
                int sum = 0;
                for (int j = i; j < i + k; j++) {
                    sum += nums[j];
                }
                answer[i] = sum;
                continue;
            }
            
            // 将频率信息转换为vector进行排序
            vector<pair<int, int>> elements; // (频率, 数值)
            for (auto& [num, count] : freq) {
                elements.push_back({count, num});
            }
            
            // 排序：先按频率降序，频率相同按数值降序
            sort(elements.begin(), elements.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.first != b.first) {
                    return a.first > b.first;
                }
                return a.second > b.second;
            });
            
            // 计算前x个元素的总和
            int sum = 0;
            for (int j = 0; j < x; j++) {
                sum += elements[j].first * elements[j].second;
            }
            answer[i] = sum;
        }
        
        return answer;
    }
};
```

复杂度分析


- 时间复杂度：O(nklogk) n遍历，k排序
- 空间复杂度：O(k)

