---
date: 2025-09-09
category:
  - LeetCode每日一题
tag:
  - 队列
  - 前缀和
  - 差分数组
---

# [2327. 知道秘密的人数](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/)

在第 `1` 天，有一个人发现了一个秘密。

给你一个整数 `delay` ，表示每个人会在发现秘密后的 `delay` 天之后，**每天** 给一个新的人 **分享** 秘密。同时给你一个整数 `forget` ，表示每个人在发现秘密 `forget` 天之后会 **忘记** 这个秘密。一个人 **不能** 在忘记秘密那一天及之后的日子里分享秘密。

给你一个整数 `n` ，请你返回在第 `n` 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 `109 + 7` **取余** 后返回。

 

**示例 1：**

```
输入：n = 6, delay = 2, forget = 4
输出：5
解释：
第 1 天：假设第一个人叫 A 。（一个人知道秘密）
第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）
第 3 天：A 把秘密分享给 B 。（两个人知道秘密）
第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）
第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）
第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）
```

**示例 2：**

```
输入：n = 4, delay = 1, forget = 3
输出：6
解释：
第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）
第 2 天：A 把秘密分享给 B 。（两个人知道秘密）
第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）
第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）
```

 

**提示：**

- `2 <= n <= 1000`
- `1 <= delay < forget <= n`

# 解题思路

直接解法：

由于每个人在第n天得知的情况（已得知x天）并不相同，但可以确认的是，每个人在1-n范围内，只会在某一天刚得知。

因此设计数组known，known[i]表示恰好在第i天得知消息的人数。

循环可以设计为，先判断某一天恰好有多少人得知，判断他们是否满足在第i天还记得。

然后，根据forget和delay，循环更新后续的known恰好得知的数组。

该过程模拟消息传播，不会出现重复计算。

```
class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        const int MOD = 1'000'000'007;
        // known[i] 表示恰好在第 i 天得知秘密的人数
        vector<int> known(n + 1);
        known[1] = 1;
        long long ans = 0;

        for (int i = 1; i <= n; i++) {
            // 统计在第 n 天没有忘记秘密的人数
            // 这要求 i+forget-1 >= n，解得 i >= n-forget+1
            if (i >= n - forget + 1) {
                ans += known[i];
            }
            // 恰好在第 i 天得知秘密的人，会在第 [i+delay, i+forget-1] 天分享秘密
            for (int j = i + delay; j <= min(i + forget - 1, n); j++) {
                known[j] = (known[j] + known[i]) % MOD; // known[j] += known[i]
            }
        }

        return ans % MOD;
    }
};
```

法1：差分数组优化

```
class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        const int MOD = 1'000'000'007;
        vector<int> diff(n + 1);
        diff[1] = 1;
        diff[2] = -1;
        int known = 0;
        long long ans = 0;

        for (int i = 1; i <= n; i++) {
            // 加上 diff[i] 后，known 表示恰好在第 i 天得知秘密的人数
            known = (known + diff[i]) % MOD;
            // 统计在第 n 天没有忘记秘密的人数
            if (i >= n - forget + 1) {
                ans += known;
            }
            // 恰好在第 i 天得知秘密的人，会在第 [i+delay, i+forget-1] 天分享秘密
            if (i + delay <= n) {
                diff[i + delay] = (diff[i + delay] + known) % MOD;
            }
            if (i + forget <= n) {
                diff[i + forget] = (diff[i + forget] - known + MOD) % MOD; // +MOD 保证结果非负
            }
        }

        return ans % MOD;
    }
};
```

法2：前缀和

```
class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        const int MOD = 1'000'000'007;
        vector<int> sum(n + 1); // known 数组的前缀和
        sum[1] = 1;

        for (int j = 2; j <= n; j++) {
            int known = (sum[max(j - delay, 0)] - sum[max(j - forget, 0)]) % MOD;
            sum[j] = (sum[j - 1] + known) % MOD;
        }

        int ans = sum[n] - sum[max(n - forget, 0)];
        return (ans % MOD + MOD) % MOD; // 保证答案非负
    }
};
```



复杂度分析

- 时间复杂度：O(n)
- 空间复杂度：O(n)
