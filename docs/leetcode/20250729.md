---
date: 2025-07-29
category:
  - LeetCode每日一题
tag:
  - 位运算
  - 数组
  - 反向遍历
---



# [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)

中等

题目描述



给你一个长度为 `n` 下标从 **0** 开始的数组 `nums` ，数组中所有数字均为非负整数。对于 `0` 到 `n - 1` 之间的每一个下标 `i` ，你需要找出 `nums` 中一个 **最小** 非空子数组，它的起始位置为 `i` （包含这个位置），同时有 **最大** 的 **按位或运算值** 。

- 换言之，令 `Bij` 表示子数组 `nums[i...j]` 的按位或运算的结果，你需要找到一个起始位置为 `i` 的最小子数组，这个子数组的按位或运算的结果等于 `max(Bik)` ，其中 `i <= k <= n - 1` 。

*解释：只要求计算从i开始的所有子数组，所以answer[n-1]必定为1.*

一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 `n` 的整数数组 `answer`，其中 `answer[i]`是开始位置为 `i` ，按位或运算结果最大，且 **最短** 子数组的长度。

**子数组** 是数组里一段连续非空元素组成的序列。

 

**示例 1：**

```
输入：nums = [1,0,2,1,3]
输出：[3,3,2,2,1]
解释：
任何位置开始，最大按位或运算的结果都是 3 。
- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。
- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。
- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。
- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。
- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。
所以我们返回 [3,3,2,2,1] 。
```

**示例 2：**

```
输入：nums = [1,2]
输出：[2,1]
解释：
下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。
下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。
所以我们返回 [2,1] 。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 105`
- `0 <= nums[i] <= 109`



# 解题思路

从右向左遍历

直接为每个 i 计算最大值和最短长度会导致 O(n^2) 的时间复杂度，这对于 n 达到 10^5 来说太慢了。

我们可以通过从右向左遍历（从 i = n-1到 0）来优化。在遍历过程中，我们维护一个辅助数据结构，记录对于每个二进制位（0 到 30），最右边（即下标最大）出现该位的元素的下标。

1. 初始化一个大小为 31 的数组 last，所有元素为 0。
2. 从 i = n-1 循环到 0：
   a. **更新 last 数组**：对于当前数字 nums[i]，检查它的每一个二进制位。如果 nums[i] 的第 b 位是 1，就更新 last[b] = i，因为 i 是我们目前遇到的最靠左的包含该位的下标。
   b. **确定子数组的终点 j**：为了让子数组 nums[i...j] 的按位或值最大化（即包含从 i 到末尾所有可能出现的位），这个子数组必须延伸到足够远，以包含所有这些位。终点 j 必须是所有 last[b] 中的最大值。也就是说，j = max(last[0], last[1], ..., last[30])。
   c. **计算长度**：最短的满足条件的子数组长度就是 j - i + 1。我们将这个长度存入 answer[i]。
3. 循环结束后，返回 answer 数组。

复杂度分析：

- **时间复杂度**: O(n * k)，其中 n 是数组的长度，k 是整数的位数（在这里是 31=logC，参考数据范围int）。可以看作是 O(n)。
- **空间复杂度**: O(k)，我们使用了一个大小为 k 的 last 数组来存储位的最后出现位置。因为 k 是常数，

```
class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
    	int n=nums.size();
        vector<int> answer(n);
        vector<int> last(31,0);
        for(int i=n-1;i>=0;i--){
        	int j=i;
            for(int bit=0;bit<31;bit++){
                if(nums[i]>>bit&1){
                    last[bit]=i;
                }
            }
            for(int bit=0;bit<31;bit++){
                j=max(j,last[bit]);
            }
            answer[i]=j-i+1;
        }
        return answer;
        
    }
};
```

