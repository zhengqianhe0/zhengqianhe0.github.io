---
date: 2025-10-11
category:
  - LeetCode每日一题
tag:
  - 二分查找
  - 哈希表
  - 数组
  - 双指针
---

# [3186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)

一个魔法师有许多不同的咒语。

给你一个数组 `power` ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。

已知魔法师使用伤害值为 `power[i]` 的咒语时，他们就 **不能** 使用伤害为 `power[i] - 2` ，`power[i] - 1` ，`power[i] + 1` 或者 `power[i] + 2` 的咒语。

每个咒语最多只能被使用 **一次** 。

请你返回这个魔法师可以达到的伤害值之和的 **最大值** 。

 

**示例 1：**

**输入：**power = [1,1,3,4]

**输出：**6

**解释：**

可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。

**示例 2：**

**输入：**power = [7,1,6,6]

**输出：**13

**解释：**

可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。

 

**提示：**

- `1 <= power.length <= 105`
- `1 <= power[i] <= 109`

# 解题思路



```
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        // 统计每个伤害值出现的次数
        unordered_map<int, int> cnt;
        for (int x : power) {
            cnt[x]++;
        }

        // 将 map 转换为 vector<pair<int, int>>，便于排序和索引访问
        // pair.first 是伤害值，pair.second 是出现次数
        vector<pair<int, int>> a(cnt.begin(), cnt.end());

        // 按伤害值（即 pair 的 first）升序排序
        ranges::sort(a);

        int n = a.size();  // 去重后的不同伤害值个数

        // 记忆化数组：memo[i] 表示考虑前 i+1 个伤害值（即 a[0] 到 a[i]）时能获得的最大总伤害
        vector<long long> memo(n, -1);

        // 定义递归 lambda 函数，使用 Y-combinator 风格实现递归
        // [&] 捕获外部变量（如 a, memo） by reference
        // auto&& dfs：通用引用，允许传入自身（实现递归）
        auto dfs = [&](auto&& dfs, int i) -> long long {
            // 边界条件：如果 i < 0，说明没有可选的伤害值，返回 0
            if (i < 0) {
                return 0;
            }

            // 引用 memo[i]，避免重复计算
            long long& res = memo[i];
            if (res != -1) {
                return res;  // 已计算过，直接返回
            }

            // 解构当前伤害值 x 和其出现次数 c
            auto& [x, c] = a[i];

            // 找到第一个不能与当前伤害值 x 同时选择的位置 j
            // 规则是：不能选择 [x-2, x-1, x+1, x+2] 范围内的其他伤害值？
            // 实际上题目隐含规则是：如果选择了伤害值 x，
            // 就不能选择 x-1 和 x-2（因为它们与 x 相邻或次相邻，会互相干扰）
            // 所以我们要跳过所有 >= x-2 的值，找到第一个 < x-2 的位置
            int j = i;
            while (j && a[j - 1].first >= x - 2) {
                j--;
            }
            // 此时 a[j] 是第一个满足 a[j].first < x - 2 的元素（或 j == 0）

            // 两种选择：
            // 1. 不选当前伤害值 x：dfs(dfs, i - 1)
            // 2. 选当前伤害值 x：总伤害 = x * c + dfs(dfs, j - 1)
            // 取两者最大值
            return res = max(dfs(dfs, i - 1), dfs(dfs, j - 1) + (long long)x * c);
        };

        // 从最后一个元素开始递归
        return dfs(dfs, n - 1);
    }
};
```

复杂度分析


- 时间复杂度：O(nlogn)  记忆化搜索，时间空间都是n，其中排序为nlogn
- 空间复杂度：O(n)
