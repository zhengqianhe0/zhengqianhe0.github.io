---
date: 2025-08-20
category:
  - 中等
tag:
  - 数组
  - 动态规划
  - 矩阵
---

# [1277. 统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/)

给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。

 

**示例 1：**

```
输入：matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
输出：15
解释： 
边长为 1 的正方形有 10 个。
边长为 2 的正方形有 4 个。
边长为 3 的正方形有 1 个。
正方形的总数 = 10 + 4 + 1 = 15.
```

**示例 2：**

```
输入：matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
输出：7
解释：
边长为 1 的正方形有 6 个。 
边长为 2 的正方形有 1 个。
正方形的总数 = 6 + 1 = 7.
```

 

**提示：**

- `1 <= arr.length <= 300`
- `1 <= arr[0].length <= 300`
- `0 <= arr[i][j] <= 1`

# 解题思路

思路可以仿照昨天的一维的0数组的判断方法，即判断遇到1后遍历右下角是否能够成正方形子矩阵。但是时间复杂度上需要m*n遍历整个矩形并内部二维循环。

因此采用动态规划，时间空间复杂度都是矩形大小mn。

转移方程：设f(i,j)代表以(i,j)为右下角的矩形的最大边长，如果它自己的值是0那就是0。如果它自己的值是1，那么它一定等于（左，上，左上）三个小一个宽度的矩形中的最小的+1。

f(i,j)同时还可以代表以这个坐标为右下角的所有矩形数。因此ans为所有f的和。

```
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        int m=matrix.size(), n=matrix[0].size();
        vector<vector<int>> f(m,vector<int>(n,0));
        int ans=0;
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(i==0||j==0){
                    f[i][j]=matrix[i][j];
                }else if(matrix[i][j]==0){
                    f[i][j]=0;
                }else{
                    f[i][j]=min({f[i][j-1],f[i-1][j],f[i-1][j-1]})+1;
                }
                ans+=f[i][j];
            }
        }
        return ans;
    }
};
```

复杂度分析

- 时间复杂度：O(mn)
- 空间复杂度：O(mn)

  
