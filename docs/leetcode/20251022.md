---
date: 2025-10-22
category:
  - LeetCode每日一题
tag:
  - 数组
  - 排序
  - 差分数组
  - 前缀和
---

# [3347. 执行操作后元素的最高频率 II](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)

给你一个整数数组 `nums` 和两个整数 `k` 和 `numOperations` 。

你必须对 `nums` 执行 **操作** `numOperations` 次。每次操作中，你可以：

- 选择一个下标 `i` ，它在之前的操作中 **没有** 被选择过。
- 将 `nums[i]` 增加范围 `[-k, k]` 中的一个整数。

在执行完所有操作以后，请你返回 `nums` 中出现 **频率最高** 元素的出现次数。

一个元素 `x` 的 **频率** 指的是它在数组中出现的次数。

 

**示例 1：**

**输入：**nums = [1,4,5], k = 1, numOperations = 2

**输出：**2

**解释：**

通过以下操作得到最高频率 2 ：

- 将 `nums[1]` 增加 0 ，`nums` 变为 `[1, 4, 5]` 。
- 将 `nums[2]` 增加 -1 ，`nums` 变为 `[1, 4, 4]` 。

**示例 2：**

**输入：**nums = [5,11,20,20], k = 5, numOperations = 1

**输出：**2

**解释：**

通过以下操作得到最高频率 2 ：

- 将 `nums[1]` 增加 0 。

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 1059
- `0 <= k <= 109`
- `0 <= numOperations <= nums.length`

# 解题思路

和昨天一样，只是数据范围变大，所以必须使用前缀和优化，使用map数据结构优化到log级别的插入

```
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        // 问题背景：每个元素可修改为[x-k, x+k]范围内的任意整数（最多修改numOperations次）
        // 目标：找到修改后数组中出现次数最多的元素的频率
        
        // cnt用于统计原始数组中每个元素的出现次数（初始频率）
        unordered_map<int, int> cnt;
        // diff是有序差分数组，用于高效计算"每个可能的目标值x被多少个原始元素的修改范围覆盖"
        map<int, int> diff; 
        
        for (int x : nums) {
            cnt[x]++;  // 统计原始元素x的出现次数
            
            // 确保x被包含在diff的键中（后续遍历会用到该位置的原始频率）
            diff[x];
            
            // 核心：标记原始元素x的修改范围[x-k, x+k]对差分数组的影响
            // 对区间起点x-k做+1操作，表示从这里开始的范围都能被x修改覆盖
            diff[x - k]++;
            // 对区间终点x+k的下一个位置做-1操作，表示从这里开始退出x的覆盖范围
            // （利用差分数组特性，后续求前缀和即可得到每个位置被覆盖的次数）
            diff[x + k + 1]--;
        }
        
        int ans = 0;          // 存储最大频率结果
        int sum_d = 0;        // 差分数组的前缀和，代表当前x被多少个原始元素的范围覆盖
        
        // 遍历所有可能的目标值x（diff的键包含了所有关键位置：原始元素和区间边界）
        for (auto& [x, d] : diff) {
            sum_d += d;  // 累加差分值，得到x被覆盖的总次数（即最多有多少元素能修改为x）
            
            // 计算x的最大可能频率：
            // 1. 不能超过sum_d（最多只有这么多元素能改成x）
            // 2. 不能超过原始x的频率 + 最大操作次数（操作次数有限制）
            // 取两者最小值作为x的最大可能频率，更新全局最大值
            ans = max(ans, min(sum_d, cnt[x] + numOperations));
        }
        
        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(nlogn) map的插入删除是logn
- 空间复杂度：O(n)
