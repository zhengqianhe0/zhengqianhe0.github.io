---
date: 2025-08-31
category:
  - 困难
tag:
  - 数组
  - 矩阵
  - 哈希表
  - 回溯
---

# [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```

 

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`
- 题目数据 **保证** 输入数独仅有一个解

# 解题思路

回溯法

```
class Solution {
private:
    // line[i][digit]: 记录第i行是否已经填入数字digit+1
    bool line[9][9];
    // column[j][digit]: 记录第j列是否已经填入数字digit+1
    bool column[9][9];
    // block[i][j][digit]: 记录第(i,j)个3×3宫格是否已经填入数字digit+1
    bool block[3][3][9];
    // valid: 标记是否找到了有效的解
    bool valid;
    // spaces: 存储所有需要填充的空格位置
    vector<pair<int, int>> spaces;

public:
    // 深度优先搜索函数
    // board: 数独棋盘
    // pos: 当前处理的是spaces中的第pos个空格
    void dfs(vector<vector<char>>& board, int pos) {
        // 如果所有空格都已填完，说明找到了解
        if (pos == spaces.size()) {
            valid = true;  // 标记找到解
            return;
        }

        // 获取当前要填充的空格位置
        auto [i, j] = spaces[pos];
        
        // 尝试填入数字1-9
        for (int digit = 0; digit < 9 && !valid; ++digit) {
            // 检查数字digit+1是否可以填入位置(i,j)
            // 条件：该数字在当前行、列、3×3宫格中都未出现
            if (!line[i][digit] && !column[j][digit] && !block[i / 3][j / 3][digit]) {
                // 标记该数字已在对应行、列、宫格中使用
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;
                // 在棋盘上填入数字
                board[i][j] = digit + '0' + 1;
                // 递归处理下一个空格
                dfs(board, pos + 1);
                // 回溯：取消标记（注意：这里不重置board[i][j]，因为找到解后不需要回溯了）
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = false;
            }
        }
    }

    // 主函数：解决数独问题
    void solveSudoku(vector<vector<char>>& board) {
        // 初始化所有标记数组为false
        memset(line, false, sizeof(line));
        memset(column, false, sizeof(column));
        memset(block, false, sizeof(block));
        valid = false;  // 初始化未找到解

        // 预处理：扫描整个棋盘
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    // 如果是空格，记录位置
                    spaces.emplace_back(i, j);
                }
                else {
                    // 如果是数字，更新对应的标记数组
                    int digit = board[i][j] - '0' - 1;  // 将字符转换为0-8的索引
                    line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;
                }
            }
        }

        // 从第0个空格开始进行深度优先搜索
        dfs(board, 0);
    }
};
```

复杂度分析

- 时间复杂度：O(9^n) ，n为空格的个数
- 空间复杂度：O(n)，递归栈深度

  
