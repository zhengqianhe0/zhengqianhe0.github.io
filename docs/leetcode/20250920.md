---
date: 2025-09-20
category:
  - LeetCode每日一题
tag:
  - 设计
  - 哈希表
  - 数组
  - 优先队列
---

# [3508. 设计路由器](https://leetcode.cn/problems/implement-router/)

请你设计一个数据结构来高效管理网络路由器中的数据包。每个数据包包含以下属性：

- `source`：生成该数据包的机器的唯一标识符。
- `destination`：目标机器的唯一标识符。
- `timestamp`：该数据包到达路由器的时间戳。

实现 `Router` 类：

`Router(int memoryLimit)`：初始化路由器对象，并设置固定的内存限制。

- `memoryLimit` 是路由器在任意时间点可以存储的 **最大** 数据包数量。
- 如果添加一个新数据包会超过这个限制，则必须移除 **最旧的** 数据包以腾出空间。

`bool addPacket(int source, int destination, int timestamp)`：将具有给定属性的数据包添加到路由器。

- 如果路由器中已经存在一个具有相同 `source`、`destination` 和 `timestamp` 的数据包，则视为重复数据包。
- 如果数据包成功添加（即不是重复数据包），返回 `true`；否则返回 `false`。

`int[] forwardPacket()`：以 FIFO（先进先出）顺序转发下一个数据包。

- 从存储中移除该数据包。
- 以数组 `[source, destination, timestamp]` 的形式返回该数据包。
- 如果没有数据包可以转发，则返回空数组。

`int getCount(int destination, int startTime, int endTime)`：

- 返回当前存储在路由器中（即尚未转发）的，且目标地址为指定 `destination` 且时间戳在范围 `[startTime, endTime]`（包括两端）内的数据包数量。

**注意**：对于 `addPacket` 的查询会按照 `timestamp` 的递增顺序进行。

 

**示例 1：**

**输入：**
["Router", "addPacket", "addPacket", "addPacket", "addPacket", "addPacket", "forwardPacket", "addPacket", "getCount"]
[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]

**输出：**
[null, true, true, false, true, true, [2, 5, 90], true, 1]

**解释：**

`Router router = new Router(3);` // 初始化路由器，内存限制为 3。
`router.addPacket(1, 4, 90);` // 数据包被添加，返回 True。
`router.addPacket(2, 5, 90);` // 数据包被添加，返回 True。
`router.addPacket(1, 4, 90);` // 这是一个重复数据包，返回 False。
`router.addPacket(3, 5, 95);` // 数据包被添加，返回 True。
`router.addPacket(4, 5, 105);` // 数据包被添加，`[1, 4, 90]` 被移除，因为数据包数量超过限制，返回 True。
`router.forwardPacket();` // 转发数据包 `[2, 5, 90]` 并将其从路由器中移除。
`router.addPacket(5, 2, 110);` // 数据包被添加，返回 True。
`router.getCount(5, 100, 110);` // 唯一目标地址为 5 且时间在 `[100, 110]` 范围内的数据包是 `[4, 5, 105]`，返回 1。

**示例 2：**

**输入：**
["Router", "addPacket", "forwardPacket", "forwardPacket"]
[[2], [7, 4, 90], [], []]

**输出：**
[null, true, [7, 4, 90], []]

**解释：**

`Router router = new Router(2);` // 初始化路由器，内存限制为 2。
`router.addPacket(7, 4, 90);` // 返回 True。
`router.forwardPacket();` // 返回 `[7, 4, 90]`。
`router.forwardPacket();` // 没有数据包可以转发，返回 `[]`。

 

**提示：**

- `2 <= memoryLimit <= 105`
- `1 <= source, destination <= 2 * 105`
- `1 <= timestamp <= 109`
- `1 <= startTime <= endTime <= 109`
- `addPacket`、`forwardPacket` 和 `getCount` 方法的总调用次数最多为 `105`。
- 对于 `addPacket` 的查询，`timestamp` 按递增顺序给出。

# 解题思路

题目要求 FIFO（先进先出），这可以用队列实现。

为了判重，可以用哈希表记录数据包。

对于 getCount，需要按照 destination 分组，所以要用哈希表套队列。

具体来说，创建三个数据结构：

packetQ：存储数据包的队列。
packetSet：存储所有未转发的数据包，方便判重。
destToTimestamps：哈希表套队列，哈希表的 key 是 destination，value 是对应的由 timestamp 组成的队列。
addPacket 和 forwardPacket 按题目要求实现，具体见代码。

getCount 可以用二分查找，见 34. 在排序数组中查找元素的第一个和最后一个位置。

为了方便二分，可以用列表（数组）模拟队列，额外用一个变量 head 表示队首的下标。

```
struct TupleHash {
    template<typename T>
    static void hash_combine(size_t& seed, const T& v) {
        // 参考 boost::hash_combine
        seed ^= hash<T>{}(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }

    template<typename Tuple, size_t Index = 0>
    static void hash_tuple(size_t& seed, const Tuple& t) {
        if constexpr (Index < tuple_size_v<Tuple>) {
            hash_combine(seed, get<Index>(t));
            hash_tuple<Tuple, Index + 1>(seed, t);
        }
    }

    template<typename... Ts>
    size_t operator()(const tuple<Ts...>& t) const {
        size_t seed = 0;
        hash_tuple(seed, t);
        return seed;
    }
};

class Router {
    int memory_limit;
    queue<tuple<int, int, int>> packet_q; // packet 队列
    // 注：如果不想手写 TupleHash，可以用 set
    unordered_set<tuple<int, int, int>, TupleHash> packet_set; // packet 集合
    unordered_map<int, pair<vector<int>, int>> dest_to_timestamps; // destination -> ([timestamp], head)

public:
    Router(int memoryLimit) {
        memory_limit = memoryLimit;
    }

    bool addPacket(int source, int destination, int timestamp) {
        auto packet = tuple(source, destination, timestamp);
        if (!packet_set.insert(packet).second) { // packet 在 packet_set 中
            return false;
        }
        if (packet_q.size() == memory_limit) { // 太多了
            forwardPacket();
        }
        packet_q.push(packet); // 入队
        dest_to_timestamps[destination].first.push_back(timestamp);
        return true;
    }

    vector<int> forwardPacket() {
        if (packet_q.empty()) {
            return {};
        }
        auto packet = packet_q.front(); // 出队
        packet_q.pop();
        packet_set.erase(packet);
        auto [source, destination, timestamp] = packet;
        dest_to_timestamps[destination].second++; // 队首下标加一，模拟出队
        return {source, destination, timestamp};
    }

    int getCount(int destination, int startTime, int endTime) {
        auto& [timestamps, head] = dest_to_timestamps[destination];
        auto left = ranges::lower_bound(timestamps.begin() + head, timestamps.end(), startTime);
        auto right = ranges::upper_bound(timestamps.begin() + head, timestamps.end(), endTime);
        return right - left;
    }
};
```

复杂度分析

- 时间复杂度：getCount 是 O(logmin(q,memoryLimit))，其中 q 是 addPacket 的调用次数。其余操作为 O(1)。

- 空间复杂度：O(min(q,memoryLimit))。

  
