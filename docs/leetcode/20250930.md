---
date: 2025-09-30
category:
  - LeetCode每日一题
tag:
  - 数学
  - 数组
---

# [2221. 数组的三角和](https://leetcode.cn/problems/find-triangular-sum-of-an-array/)

给你一个下标从 **0** 开始的整数数组 `nums` ，其中 `nums[i]` 是 `0` 到 `9` 之间（两者都包含）的一个数字。

`nums` 的 **三角和** 是执行以下操作以后最后剩下元素的值：

1. `nums` 初始包含 `n` 个元素。如果 `n == 1` ，**终止** 操作。否则，**创建** 一个新的下标从 **0** 开始的长度为 `n - 1` 的整数数组 `newNums` 。
2. 对于满足 `0 <= i < n - 1` 的下标 `i` ，`newNums[i]` **赋值** 为 `(nums[i] + nums[i+1]) % 10` ，`%` 表示取余运算。
3. 将 `newNums` **替换** 数组 `nums` 。
4. 从步骤 1 开始 **重复** 整个过程。

请你返回 `nums` 的三角和。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png)

```
输入：nums = [1,2,3,4,5]
输出：8
解释：
上图展示了得到数组三角和的过程。
```

**示例 2：**

```
输入：nums = [5]
输出：5
解释：
由于 nums 中只有一个元素，数组的三角和为这个元素自己。
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 9`

# 解题思路

很明显的组合数，但是计算乘法时会越界过大，即使是long long。可以使用动态规划拆解乘法过程只求余数/lucas定理和中国剩余定理

```
class Solution {
public:
    long long combinations(int n, int k) {
        if (k > n / 2) {
            k = n - k;
        }
        long long res = 1;
        for (int i = 1; i <= k; ++i) {
            res = res * (n - i + 1) / i;
        }
        return res;
    }
    int triangularSum(vector<int>& nums) {
        int sum=0;
        int n=nums.size();
        for(int i=0;i<n;i++){
            sum+=nums[i]*combinations(n-1,i)%10;
        }
        return sum%10;
    }
};
```

该题限制并不大， 可以直接模拟
```
class Solution {
public:
    int triangularSum(vector<int>& nums) {
        // 每循环一轮，数组长度就减一
        for (int n = nums.size() - 1; n > 0; n--) {
            for (int i = 0; i < n; i++) {
                nums[i] = (nums[i] + nums[i + 1]) % 10;
            }
        }
        return nums[0];
    }
};
```

复杂度分析


- 时间复杂度：O(n^2) 
- 空间复杂度：O(1)
