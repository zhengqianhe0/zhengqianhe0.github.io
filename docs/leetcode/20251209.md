---
date: 2025-12-09
category:
  - LeetCode每日一题
tag:
  - 数组
  - 哈希表
---

# [3583. 统计特殊三元组](https://leetcode.cn/problems/count-special-triplets/)

给你一个整数数组 `nums`。

**特殊三元组** 定义为满足以下条件的下标三元组 `(i, j, k)`：

- `0 <= i < j < k < n`，其中 `n = nums.length`
- `nums[i] == nums[j] * 2`
- `nums[k] == nums[j] * 2`

返回数组中 **特殊三元组** 的总数。

由于答案可能非常大，请返回结果对 `109 + 7` 取余数后的值。

 

**示例 1：**

**输入：** nums = [6,3,6]

**输出：** 1

**解释：**

唯一的特殊三元组是 `(i, j, k) = (0, 1, 2)`，其中：

- `nums[0] = 6`, `nums[1] = 3`, `nums[2] = 6`
- `nums[0] = nums[1] * 2 = 3 * 2 = 6`
- `nums[2] = nums[1] * 2 = 3 * 2 = 6`

**示例 2：**

**输入：** nums = [0,1,0,0]

**输出：** 1

**解释：**

唯一的特殊三元组是 `(i, j, k) = (0, 2, 3)`，其中：

- `nums[0] = 0`, `nums[2] = 0`, `nums[3] = 0`
- `nums[0] = nums[2] * 2 = 0 * 2 = 0`
- `nums[3] = nums[2] * 2 = 0 * 2 = 0`

**示例 3：**

**输入：** nums = [8,4,2,8,4]

**输出：** 2

**解释：**

共有两个特殊三元组：

- ```
  (i, j, k) = (0, 1, 3)
  ```

  - `nums[0] = 8`, `nums[1] = 4`, `nums[3] = 8`
  - `nums[0] = nums[1] * 2 = 4 * 2 = 8`
  - `nums[3] = nums[1] * 2 = 4 * 2 = 8`

- ```
  (i, j, k) = (1, 2, 4)
  ```

  - `nums[1] = 4`, `nums[2] = 2`, `nums[4] = 4`
  - `nums[1] = nums[2] * 2 = 2 * 2 = 4`
  - `nums[4] = nums[2] * 2 = 2 * 2 = 4`

 

**提示：**

- `3 <= n == nums.length <= 105`
- `0 <= nums[i] <= 105`

# 解题思路

三元组，枚举中间的元素最简单。

维护前后的计数哈希表，乘法原理构造匹配

```
class Solution {
public:
    int specialTriplets(vector<int>& nums) {
        const int MOD = 1'000'000'007;
        
        // suf[x]：记录 x 在整个数组中出现的次数（初始化为全数组）
        unordered_map<int, int> suf;
        for (int x : nums) {
            suf[x]++;
        }

        long long ans = 0;
        // pre[x]：记录当前遍历位置之前（即 nums[0..j-1]）x 出现的次数
        unordered_map<int, int> pre;

        // 遍历每个元素作为中间元素 nums[j]
        for (int x : nums) { // x = nums[j]
            suf[x]--; // 将 x 从后缀中移除（因为现在它是中间元素）

            // 寻找满足条件的三元组 (i, j, k)：
            // 要求 nums[i] == 2 * nums[j] 且 nums[k] == 2 * nums[j]
            // 即 nums[i] == nums[k] == 2 * x
            // pre[2*x] 是 i 的选择数，suf[2*x] 是 k 的选择数
            ans += 1LL * pre[x * 2] * suf[x * 2];

            pre[x]++; // 将 x 加入前缀，供后续 j 使用
        }
        return ans % MOD;
    }
};
```

复杂度分析


- 时间复杂度：O(n)
- 空间复杂度：O(n)

