---
date: 2025-09-10
category:
  - LeetCode每日一题
tag:
  - 贪心
  - 数组
  - 差哈希表
---

# [1733. 需要教语言的最少人数](https://leetcode.cn/problems/minimum-number-of-people-to-teach/)

在一个由 `m` 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。

给你一个整数 `n` ，数组 `languages` 和数组 `friendships` ，它们的含义如下：

- 总共有 `n` 种语言，编号从 `1` 到 `n` 。
- `languages[i]` 是第 `i` 位用户掌握的语言集合。
- `friendships[i] = [ui, vi]` 表示 `ui` 和 `vi` 为好友关系。

你可以选择 **一门** 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 **最少** 需要教会多少名用户。

请注意，好友关系没有传递性，也就是说如果 `x` 和 `y` 是好友，且 `y` 和 `z` 是好友， `x` 和 `z` 不一定是好友。

 

**示例 1：**

```
输入：n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
输出：1
解释：你可以选择教用户 1 第二门语言，也可以选择教用户 2 第一门语言。
```

**示例 2：**

```
输入：n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
输出：2
解释：教用户 1 和用户 3 第三门语言，需要教 2 名用户。
```

 

**提示：**

- `2 <= n <= 500`
- `languages.length == m`
- `1 <= m <= 500`
- `1 <= languages[i].length <= n`
- `1 <= languages[i][j] <= n`
- `1 <= ui < vi <= languages.length`
- `1 <= friendships.length <= 500`
- 所有的好友关系 `(ui, vi)` 都是唯一的。
- `languages[i]` 中包含的值互不相同。

# 解题思路

我们的目的是找出需要教语言的最少人数，那么我们首先要找出所有不能相互沟通的好友。

其次，我们只需要找到一种语言，使不能相互沟通的好友都掌握这个语言，就能够保证这些好友之间能够相互沟通。

那么如何找到这种语言呢？我们只需要统计每一种语言被多少人掌握了，然后贪心地选择被最多人掌握的语言当作目标语言即可，这是因为没有掌握该种语言的人数最少。可以证明：选择其他语言，我们需要教的人数一定不会比选择该种语言需要教的人数更少，因此这种贪心策略是正确的。

```
class Solution {
public:
    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
        // 存储无法沟通的朋友（索引）
        unordered_set<int> cncon;
        
        // 遍历所有朋友对，找出无法沟通的朋友
        for(auto friendship : friendships) {
            // 记录第一个朋友会的语言
            unordered_map<int, int> mp;
            // 标记这对朋友是否能沟通
            bool conm = false;
            
            // 将第一个朋友会的所有语言存入哈希表
            for(int lan : languages[friendship[0]-1]) {
                mp[lan] = 1;
            }
            
            // 检查第二个朋友是否会第一个朋友会的任何语言
            for(int lan : languages[friendship[1]-1]) {
                if(mp[lan]) {
                    // 找到共同语言，标记为可以沟通
                    conm = true;
                    break;
                }
            }
            
            // 如果没有共同语言，将这两个朋友加入无法沟通集合
            if(!conm) {
                // 注意：原代码这里有拼写错误，应该是!conm而不是!comn
                cncon.insert(friendship[0]-1);
                cncon.insert(friendship[1]-1);
            }
        }
        
        // 如果所有朋友都能沟通，不需要教任何人
        if(cncon.empty()) return 0;
        
        // 统计每种语言在无法沟通的人中的使用次数
        int max_cnt = 0;
        vector<int> cnt(n+1, 0);
        
        for(auto person : cncon) {
            for(int lan : languages[person]) {
                cnt[lan]++;
                // 更新最多人会的语言的计数
                max_cnt = max(max_cnt, cnt[lan]);
            }
        }
        
        // 最少需要教的人数 = 无法沟通的总人数 - 最多人会的那种语言的人数
        // 因为选择最多人已经会的语言来教，可以最小化需要教学的人数
        return cncon.size() - max_cnt;
    }
};
```

复杂度分析

- 时间复杂度：O(mn)，遍历好友对和语言数
- 空间复杂度：O(m+n)，需要额外的空间存储不能沟通的人，以及语言数存储cnt数组
