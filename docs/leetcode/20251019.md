---
date: 2025-10-19
category:
  - LeetCode每日一题
tag:
  - 数学
  - 字符串
  - DFS
---

# [1625. 执行操作后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/)

给你一个字符串 `s` 以及两个整数 `a` 和 `b` 。其中，字符串 `s` 的长度为偶数，且仅由数字 `0` 到 `9` 组成。

你可以在 `s` 上按任意顺序多次执行下面两个操作之一：

- 累加：将 `a` 加到 `s` 中所有下标为奇数的元素上（**下标从 0 开始**）。数字一旦超过 `9` 就会变成 `0`，如此循环往复。例如，`s = "3456"` 且 `a = 5`，则执行此操作后 `s` 变成 `"3951"`。
- 轮转：将 `s` 向右轮转 `b` 位。例如，`s = "3456"` 且 `b = 1`，则执行此操作后 `s` 变成 `"6345"`。

请你返回在 `s` 上执行上述操作任意次后可以得到的 **字典序最小** 的字符串。

如果两个字符串长度相同，那么字符串 `a` 字典序比字符串 `b` 小可以这样定义：在 `a` 和 `b` 出现不同的第一个位置上，字符串 `a` 中的字符出现在字母表中的时间早于 `b` 中的对应字符。例如，`"0158”` 字典序比 `"0190"` 小，因为不同的第一个位置是在第三个字符，显然 `'5'` 出现在 `'9'` 之前。

 

**示例 1：**

```
输入：s = "5525", a = 9, b = 2
输出："2050"
解释：执行操作如下：
初态："5525"
轮转："2555"
累加："2454"
累加："2353"
轮转："5323"
累加："5222"
累加："5121"
轮转："2151"
累加："2050"
无法获得字典序小于 "2050" 的字符串。
```

**示例 2：**

```
输入：s = "74", a = 5, b = 1
输出："24"
解释：执行操作如下：
初态："74"
轮转："47"
累加："42"
轮转："24"
无法获得字典序小于 "24" 的字符串。
```

**示例 3：**

```
输入：s = "0011", a = 4, b = 2
输出："0011"
解释：无法获得字典序小于 "0011" 的字符串。
```

 

**提示：**

- `2 <= s.length <= 100`
- `s.length` 是偶数
- `s` 仅由数字 `0` 到 `9` 组成
- `1 <= a <= 9`
- `1 <= b <= s.length - 1`

# 解题思路

裴属定理：

设 𝑎,𝑏![a,b](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 是不全为零的整数。那么，对于任意整数 𝑥,𝑦![x,y](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，都有 gcd(𝑎,𝑏) ∣𝑎𝑥 +𝑏𝑦![\gcd(a,b)\mid ax+by](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 成立；而且，存在整数 𝑥,𝑦![x,y](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，使得 𝑎𝑥 +𝑏𝑦 =gcd(𝑎,𝑏)![ax+by=\gcd(a,b)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 成立。

利用这一定理，当多次添加时 

*r*=(*s*1+*ak*)mod10

*s*1+*ak*−10*q*=*r*

*ak*−10*q*=*r*−*s*1

当以上等式有解时，*r*−*s*1 是 *g*=gcd(*a*,10)的倍数，所以r与s1 mod g同余。

总结：穷举所有**可能的基础结构**（轮转），然后对每一个结构，用贪心法将其**最前面的可变位**优化到极致（最小 $t[\text{start}] \pmod g$），由此锁定了整个字符串。最后在所有这些最优化的结果中找到字典序最小的那一个。

```
class Solution {
public:
    string findLexSmallestString(string s, int a, int b) {
        int n = s.size();
        int step = gcd(b, n);
        int g = gcd(a, 10);
        string ans;

        for (int i = 0; i < n; i += step) {
            string t = s.substr(i) + s.substr(0, i); // 轮转

            auto modify = [&](int start) -> void {
                int ch = t[start] - '0'; // 最靠前的数字，越小越好
                // ch 可以变成的最小值为 ch%g
                // 例如 ch=5，g=2，那么 ch+2+2+2（模 10）后变成 1，不可能变得更小
                // 从 ch 到 ch%g，需要增加 inc，其中 +10 保证 inc 非负（循环中会 %10 保证结果在 [0,9] 中）
                int inc = ch % g - ch + 10;
                for (int j = start; j < n; j += 2) {
                    t[j] = '0' + (t[j] - '0' + inc) % 10;
                }
            };

            modify(1); // 累加操作（所有奇数下标）
            if (step % 2) { // 能对偶数下标执行累加操作
                modify(0); // 累加操作（所有偶数下标）
            }

            if (ans.empty() || t < ans) {
                ans = move(t); // 每次循环赋值比较
            }
        }

        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(n^2/gcd(b,n))
- 空间复杂度：O(n)
