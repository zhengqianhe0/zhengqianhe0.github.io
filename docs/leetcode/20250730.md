---
date: 2025-07-30
category:
  - LeetCode每日一题
tag:
  - 位运算
  - 数组
  - 脑筋急转弯
---



# [2419. 按位与最大的最长子数组](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/)

中等

提示



给你一个长度为 `n` 的整数数组 `nums` 。

考虑 `nums` 中进行 **按位与（bitwise AND）**运算得到的值 **最大** 的 **非空** 子数组。

- 换句话说，令 `k` 是 `nums` **任意** 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 `k` 的子数组。

返回满足要求的 **最长** 子数组的长度。

数组的按位与就是对数组中的所有数字进行按位与运算。

**子数组** 是数组中的一个连续元素序列。

 

**示例 1：**

```
输入：nums = [1,2,3,3,2,2]
输出：2
解释：
子数组按位与运算的最大值是 3 。
能得到此结果的最长子数组是 [3,3]，所以返回 2 。
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：1
解释：
子数组按位与运算的最大值是 4 。 
能得到此结果的最长子数组是 [4]，所以返回 1 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 106`

# 解题思路

核心：理解按位与的特点。与运算只有1和1与得到的是1。

两个不同的正整数按位与，结果一定比两个数中更大的那个小。

证明：从高位开始比较，如果两个数高位都是1，则继续；当遇到第一个不同时，按位与得到0；无论后面如何，结果一定比大数小，因为结果这一位是0而大数这一位是1。

另外，本题要求的是子数组，因此，答案就是数组中最大值连续子数组的长度。

代码实现：按顺序遍历，记录最大值子数组长度。遇到更大值，设置新的最大值重新计；遇到更小值计数器归零。



**复杂度分析：**

- 时间复杂度：*O*(*n*)，遍历数组一遍。
- 空间复杂度：*O*(1)。

```
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int maxvalue=nums[0];
        int ans=1,cnt=1;
        for(int i=1;i<nums.size();++i){
            if(nums[i]>maxvalue){
                ans=cnt=1;
                maxvalue=nums[i];
            }else if(nums[i]<maxvalue){
                cnt=0;
            }else if(nums[i]==maxvalue){
                cnt++;
            }
            ans=max(cnt,ans);
        }
        return ans;
    }
};
```

