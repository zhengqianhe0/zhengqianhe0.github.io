---
date: 2025-09-16
category:
  - LeetCode每日一题
tag:
  - 字符串
  - 哈希表
  - 数组
---

# [2197. 替换数组中的非互质数](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/)



给你一个整数数组 `nums` 。请你对数组执行下述操作：

1. 从 `nums` 中找出 **任意** 两个 **相邻** 的 **非互质** 数。
2. 如果不存在这样的数，**终止** 这一过程。
3. 否则，删除这两个数，并 **替换** 为它们的 **最小公倍数**（Least Common Multiple，LCM）。
4. 只要还能找出两个相邻的非互质数就继续 **重复** 这一过程。

返回修改后得到的 **最终** 数组。可以证明的是，以 **任意** 顺序替换相邻的非互质数都可以得到相同的结果。

生成的测试用例可以保证最终数组中的值 **小于或者等于** `108` 。

两个数字 `x` 和 `y` 满足 **非互质数** 的条件是：`GCD(x, y) > 1` ，其中 `GCD(x, y)` 是 `x` 和 `y` 的 **最大公约数** 。

 

**示例 1 ：**

```
输入：nums = [6,4,3,2,7,6,2]
输出：[12,7,6]
解释：
- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [12,3,2,7,6,2] 。
- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [12,2,7,6,2] 。
- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [12,7,6,2] 。
- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,6] 。
现在，nums 中不存在相邻的非互质数。
因此，修改后得到的最终数组是 [12,7,6] 。
注意，存在其他方法可以获得相同的最终数组。
```

**示例 2 ：**

```
输入：nums = [2,2,1,1,3,3,3]
输出：[2,1,1,3]
解释：
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3,3] 。
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3] 。
- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [2,1,1,3] 。
现在，nums 中不存在相邻的非互质数。 
因此，修改后得到的最终数组是 [2,1,1,3] 。 
注意，存在其他方法可以获得相同的最终数组。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`
- 生成的测试用例可以保证最终数组中的值 **小于或者等于** `108` 。

# 解题思路

数学结论已在题目中给出，任意顺序合并都可以得到一样的结果。

模拟操作，用一个栈模拟从左到右检查。

用到vector模拟栈，以尾部作为栈顶，用push back和pop back操作，back访问栈顶，empty判空。

while循环保证了每次新加入元素后完整的向左传播，让栈内两两相邻的元素互质。

```
class Solution {
public:
    vector<int> replaceNonCoprimes(vector<int>& nums) {
        vector<int> st;
        for(int x:nums){
            while(!st.empty()&&gcd(x,st.back())>1){
                x=lcm(x,st.back());
                st.pop_back();
            }
            st.push_back(x);
        }
        return st;
    }
};
```

复杂度分析

- 时间复杂度：O(nlogC) 遍历数组，lcm的最坏情况是logC，C为最大的常数 
- 空间复杂度：O(n)
