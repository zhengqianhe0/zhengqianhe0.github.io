---
date: 2025-09-17
category:
  - LeetCode每日一题
tag:
  - 设计
  - 哈希表
---

# [2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)



设计一个数字容器系统，可以实现以下功能：

- 在系统中给定下标处 **插入** 或者 **替换** 一个数字。
- **返回** 系统中给定数字的最小下标。

请你实现一个 `NumberContainers` 类：

- `NumberContainers()` 初始化数字容器系统。
- `void change(int index, int number)` 在下标 `index` 处填入 `number` 。如果该下标 `index` 处已经有数字了，那么用 `number` 替换该数字。
- `int find(int number)` 返回给定数字 `number` 在系统中的最小下标。如果系统中没有 `number` ，那么返回 `-1` 。

 

**示例：**

```
输入：
["NumberContainers", "find", "change", "change", "change", "change", "find", "change", "find"]
[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]
输出：
[null, -1, null, null, null, null, 1, null, 2]

解释：
NumberContainers nc = new NumberContainers();
nc.find(10); // 没有数字 10 ，所以返回 -1 。
nc.change(2, 10); // 容器中下标为 2 处填入数字 10 。
nc.change(1, 10); // 容器中下标为 1 处填入数字 10 。
nc.change(3, 10); // 容器中下标为 3 处填入数字 10 。
nc.change(5, 10); // 容器中下标为 5 处填入数字 10 。
nc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。
nc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。
nc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。
```

 

**提示：**

- `1 <= index, number <= 109`
- 调用 `change` 和 `find` 的 **总次数** 不超过 `105` 次。

# 解题思路

用两个哈希，分别存储下标到数字的映射，和数字到下标结合的映射。

C++语法：map的find；set的erase，insert，empty；迭代器是对于stl容器内数据的引用，可用*解引用来取值。

```
class NumberContainers {
    // 从索引映射到当前存储的数字
    unordered_map<int,int> index_to_number;

    // 从数字映射到所有存储该数字的索引集合（有序，用set保证最小索引在前）
    unordered_map<int,set<int>> number_to_indices;

public:
    // 构造函数，无需初始化，因为map和set默认为空
    NumberContainers() {
        // 什么也不做，成员变量会自动初始化为空
    }
    
    // 将索引 index 处的数字改为 number
    void change(int index, int number) {
        // 查找 index 是否已有旧数字
        auto it = index_to_number.find(index);

        // 如果 index 之前有绑定数字（即存在）
        if (it != index_to_number.end()) {
            int old_number = it->second;  // 取出旧数字

            // 从旧数字对应的索引集合中删除这个 index
            number_to_indices[old_number].erase(index);

            // 注意：即使集合变空，我们也不删除 map 中的键，因为后续可能再插入
        }

        // 更新 index -> number 的映射
        index_to_number[index] = number;

        // 将 index 插入到新数字对应的索引集合中
        number_to_indices[number].insert(index);
    }
    
    // 查找数字 number 对应的最小索引，若不存在则返回 -1
    int find(int number) {
        // 在 number_to_indices 中查找 number 对应的索引集合
        auto it = number_to_indices.find(number);

        // 如果没找到这个数字，或者该数字对应的索引集合为空
        if (it == number_to_indices.end() || it->second.empty()) {
            return -1;
        }

        // 返回集合中最小的索引（set 是有序的，begin() 是最小值）
        return *(it->second.begin());
    }
};
```

复杂度分析

- 时间复杂度：O(logq) ，q为change调用的次数
- 空间复杂度：O(q)
