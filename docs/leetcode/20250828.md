---
date: 2025-08-28
category:
  - 中等
tag:
  - 数组
  - 矩阵
  - 排序
---

# [3446. 按对角线进行矩阵排序](https://leetcode.cn/problems/sort-matrix-by-diagonals/)

给你一个大小为 `n x n` 的整数方阵 `grid`。返回一个经过如下调整的矩阵：

- **左下角三角形**（包括中间对角线）的对角线按 **非递增顺序** 排序。
- **右上角三角形** 的对角线按 **非递减顺序** 排序。

 

**示例 1：**

**输入：** grid = [[1,7,3],[9,8,2],[4,5,6]]

**输出：** [[8,2,3],[9,6,7],[4,5,1]]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/12/29/4052example1drawio.png)

标有黑色箭头的对角线（左下角三角形）应按非递增顺序排序：

- `[1, 8, 6]` 变为 `[8, 6, 1]`。
- `[9, 5]` 和 `[4]` 保持不变。

标有蓝色箭头的对角线（右上角三角形）应按非递减顺序排序：

- `[7, 2]` 变为 `[2, 7]`。
- `[3]` 保持不变。

**示例 2：**

**输入：** grid = [[0,1],[1,2]]

**输出：** [[2,1],[1,0]]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/12/29/4052example2adrawio.png)

标有黑色箭头的对角线必须按非递增顺序排序，因此 `[0, 2]` 变为 `[2, 0]`。其他对角线已经符合要求。

**示例 3：**

**输入：** grid = [[1]]

**输出：** [[1]]

**解释：**

只有一个元素的对角线已经符合要求，因此无需修改。

 

**提示：**

- `grid.length == grid[i].length == n`
- `1 <= n <= 10`
- `-105 <= grid[i][j] <= 105`

# 解题思路

模拟。分别取左下三角与右上三角，逐一按要求重新排序。

注意循环结束条件：i和j一个代表起始行或列，另一个代表循环次数，即该对角线长度。因此到达边缘时i+j=n-1.

```
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n=grid.size();
        for(int i=0;i<n;i++){
            vector<int> tmp;
            for(int j=0;i+j<n;j++){
                tmp.push_back(grid[i+j][j]);
            }
            sort(tmp.begin(),tmp.end(),greater<int>());
            for(int j=0;i+j<n;j++){
                grid[i+j][j]=tmp[j];
            }
        }
        for(int j=1;j<n;j++){
            vector<int> tmp;
            for(int i=0;j+i<n;i++){
                tmp.push_back(grid[i][j+i]);
            }
            sort(tmp.begin(),tmp.end());
            for(int i=0;j+i<n;i++){
                grid[i][j+i]=tmp[i];
            }
        }
        return grid;
    }
};
```

复杂度分析

- 时间复杂度：O(n^2logn)  以矩形宽度n遍历两次，排序算法复杂度nlogn
- 空间复杂度：O(n)

  
