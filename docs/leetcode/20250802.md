---
date: 2025-08-02
category:
  - 困难
tag:
  - 贪心
  - 数组
  - 哈希表
  - 排序
---

# [2561. 重排水果](https://leetcode.cn/problems/rearranging-fruits/)

你有两个果篮，每个果篮中有 `n` 个水果。给你两个下标从 **0** 开始的整数数组 `basket1` 和 `basket2` ，用以表示两个果篮中每个水果的交换成本。你想要让两个果篮相等。为此，可以根据需要多次执行下述操作：

- 选中两个下标 `i` 和 `j` ，并交换 `basket1` 中的第 `i` 个水果和 `basket2` 中的第 `j` 个水果。
- 交换的成本是 `min(basket1i,basket2j)` 。

根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。

返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回 `-1` 。

 **示例 1：**

```
输入：basket1 = [4,2,2,2], basket2 = [1,4,1,2]
输出：1
解释：交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。
```

**示例 2：**

```
输入：basket1 = [2,3,4,1], basket2 = [3,2,5,1]
输出：-1
解释：可以证明无法使两个果篮相等。
```

 **提示：**

- `basket1.length == bakste2.length`
- `1 <= basket1.length <= 105`
- `1 <= basket1i,basket2i <= 109`

# 解题思路

首先用哈希表遍历两个数组，数组1增加，数组2减少。最后数组里count的绝对值是相差的水果数。

然后建立一个需要交换的水果的数组。每一类水果把一半换到另一个数组即可。

根据贪心思想，只需要对交换数组中较小的一半进行操作（该操作限定了总交换次数，即操作了较小的一半一定完成了整体的交换任务。这也表示出了并不需要关注每次交换中较大的一方是多少，因为并不参与计算）。

交换的成本：当前用最小值的水果去换最大值的/借助全局最小值进行两次交换。取更小的一个加到统计结果。

**复杂度分析：**

- 时间复杂度：*O*(*n²*)，二位数组遍历。
- 空间复杂度：*O*(1)。

```
class Solution {
public:
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        unordered_map<int,int>counts;
        long long min_val=2e9+7;
        for(int fruit:basket1){
            counts[fruit]++;
            min_val=min(min_val,(long long)fruit);
        }
        for(int fruit:basket2){
            counts[fruit]--;
            min_val=min(min_val,(long long)fruit);
        }
        vector<int> to_swap;

        for(auto const& [fruit,count]:counts){
            if(count%2!=0){
                return -1;
            }
            int num_to_move=abs(count)/2;
            for(int i=0;i<num_to_move;i++){
                to_swap.push_back(fruit);
            }
        }
        sort(to_swap.begin(),to_swap.end());
        long long total_cost=0;
        int k=to_swap.size()/2;
        for(int i=0;i<k;i++){
            total_cost+=min((long long)to_swap[i],2LL*min_val);
        }
        return total_cost;
    }
};
```

