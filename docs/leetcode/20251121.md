---
date: 2025-11-21
category:
  - LeetCode每日一题
tag:
  - 字符串
  - 哈希表
  - 前缀和
---

# [1930. 长度为 3 的不同回文子序列](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)

给你一个字符串 `s` ，返回 `s` 中 **长度为 3** 的**不同回文子序列** 的个数。

即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。

**回文** 是正着读和反着读一样的字符串。

**子序列** 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。

- 例如，`"ace"` 是 `"***a\***b***c\***d***e\***"` 的一个子序列。

 

**示例 1：**

```
输入：s = "aabca"
输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- "aba" ("aabca" 的子序列)
- "aaa" ("aabca" 的子序列)
- "aca" ("aabca" 的子序列)
```

**示例 2：**

```
输入：s = "adc"
输出：0
解释："adc" 不存在长度为 3 的回文子序列。
```

**示例 3：**

```
输入：s = "bbcbaba"
输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- "bbb" ("bbcbaba" 的子序列)
- "bcb" ("bbcbaba" 的子序列)
- "bab" ("bbcbaba" 的子序列)
- "aba" ("bbcbaba" 的子序列)
```

 

**提示：**

- `3 <= s.length <= 105`
- `s` 仅由小写英文字母组成



# 解题思路

注意数组遍历函数的写法，注意bool数组的初始化，避免内存原有数据影响

```
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int ans = 0;
        for (char alpha = 'a'; alpha <= 'z'; alpha++) { // 枚举两侧字母 alpha
            int i = s.find(alpha); // 最左边的 alpha 的下标
            if (i == string::npos) { // s 中没有 alpha
                continue;
            }
            int j = s.rfind(alpha); // 最右边的 alpha 的下标

            bool has[26]={0};
            for (int k = i + 1; k < j; k++) { // 枚举中间字母 s[k]
                if (!has[s[k] - 'a']) {
                    has[s[k] - 'a'] = true; // 避免重复统计
                    ans++;
                }
            }
        }
        return ans;
    }
};

```

复杂度分析


- 时间复杂度：O(nΣ) Σ表示字母个数26
- 空间复杂度：O(Σ)

