---
date: 2025-11-15
category:
  - LeetCode每日一题
tag:
  - 字符串
  - 枚举
  - 滑动窗口
---

# [3234. 统计 1 显著的字符串的数量](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/)

给你一个二进制字符串 `s`。

请你统计并返回其中 **1 显著** 的 子字符串 的数量。

如果字符串中 1 的数量 **大于或等于** 0 的数量的 **平方**，则认为该字符串是一个 **1 显著** 的字符串 。

 

**示例 1：**

**输入：**s = "00011"

**输出：**5

**解释：**

1 显著的子字符串如下表所示。

| i    | j    | s[i..j] | 0 的数量 | 1 的数量 |
| ---- | ---- | ------- | -------- | -------- |
| 3    | 3    | 1       | 0        | 1        |
| 4    | 4    | 1       | 0        | 1        |
| 2    | 3    | 01      | 1        | 1        |
| 3    | 4    | 11      | 0        | 2        |
| 2    | 4    | 011     | 1        | 2        |

**示例 2：**

**输入：**s = "101101"

**输出：**16

**解释：**

1 不显著的子字符串如下表所示。

总共有 21 个子字符串，其中 5 个是 1 不显著字符串，因此有 16 个 1 显著子字符串。

| i    | j    | s[i..j] | 0 的数量 | 1 的数量 |
| ---- | ---- | ------- | -------- | -------- |
| 1    | 1    | 0       | 1        | 0        |
| 4    | 4    | 0       | 1        | 0        |
| 1    | 4    | 0110    | 2        | 2        |
| 0    | 4    | 10110   | 2        | 3        |
| 1    | 5    | 01101   | 2        | 3        |

 

**提示：**

- `1 <= s.length <= 4 * 104`
- `s` 仅包含字符 `'0'` 和 `'1'`。

# 解题思路

通过维护所有 `'0'` 的位置，并在遍历字符串时，对每个右端点 `r`，利用已记录的 `'0'` 位置和当前 `'1'` 的总数，枚举以 `r` 结尾、满足“0 的个数的平方 ≤ 1 的个数”的子串数量，从而高效统计符合条件的子串总数。

```
class Solution {
public:
    int numberOfSubstrings(string s) {
        vector<int> pos0 = {-1}; // 加个 -1 哨兵，方便处理 cnt0 达到最大时的计数
        int total1 = 0; // [0,r] 中的 1 的个数
        int ans = 0;
        for (int r = 0; r < s.size(); r++) {
            if (s[r] == '0') {
                pos0.push_back(r); // 记录 0 的下标
            } else {
                total1++;
                ans += r - pos0.back(); // 单独计算不含 0 的子串个数
            }

            int m = pos0.size();
            // 倒着遍历 pos0，那么 cnt0 = m - i
            for (int i = m - 1; i > 0 && (m - i) * (m - i) <= total1; i--) {
                int p = pos0[i - 1], q = pos0[i];
                int cnt0 = m - i;
                int cnt1 = r - q + 1 - cnt0; // [q,r] 中的 1 的个数 = [q,r] 的长度 - cnt0
                ans += max(q - max(cnt0 * cnt0 - cnt1, 0) - p, 0);
            }
        }
        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(n√n)
- 空间复杂度：O(n)

