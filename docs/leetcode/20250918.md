---
date: 2025-09-18
category:
  - LeetCode每日一题
tag:
  - 设计
  - 哈希表
---

# [3408. 设计任务管理器](https://leetcode.cn/problems/design-task-manager/)

一个任务管理器系统可以让用户管理他们的任务，每个任务有一个优先级。这个系统需要高效地处理添加、修改、执行和删除任务的操作。

请你设计一个 `TaskManager` 类：

- `TaskManager(vector<vector<int>>& tasks)` 初始化任务管理器，初始化的数组格式为 `[userId, taskId, priority]` ，表示给 `userId` 添加一个优先级为 `priority` 的任务 `taskId` 。
- `void add(int userId, int taskId, int priority)` 表示给用户 `userId` 添加一个优先级为 `priority` 的任务 `taskId` ，输入 **保证** `taskId` 不在系统中。
- `void edit(int taskId, int newPriority)` 更新已经存在的任务 `taskId` 的优先级为 `newPriority` 。输入 **保证** `taskId` 存在于系统中。
- `void rmv(int taskId)` 从系统中删除任务 `taskId` 。输入 **保证** `taskId` 存在于系统中。
- `int execTop()` 执行所有用户的任务中优先级 **最高** 的任务，如果有多个任务优先级相同且都为 **最高** ，执行 `taskId` 最大的一个任务。执行完任务后，`taskId` 从系统中 **删除** 。同时请你返回这个任务所属的用户 `userId` 。如果不存在任何任务，返回 -1 。

**注意** ，一个用户可能被安排多个任务。

 

**示例 1：**

**输入：**
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]

**输出：**
[null, null, null, 3, null, null, 5]

**解释：**

TaskManager taskManager = new TaskManager([[1, 101, 10], [2, 102, 20], [3, 103, 15]]); // 分别给用户 1 ，2 和 3 初始化一个任务。
taskManager.add(4, 104, 5); // 给用户 4 添加优先级为 5 的任务 104 。
taskManager.edit(102, 8); // 更新任务 102 的优先级为 8 。
taskManager.execTop(); // 返回 3 。执行用户 3 的任务 103 。
taskManager.rmv(101); // 将系统中的任务 101 删除。
taskManager.add(5, 105, 15); // 给用户 5 添加优先级为 15 的任务 105 。
taskManager.execTop(); // 返回 5 。执行用户 5 的任务 105 。

 

**提示：**

- `1 <= tasks.length <= 105`
- `0 <= userId <= 105`
- `0 <= taskId <= 105`
- `0 <= priority <= 109`
- `0 <= newPriority <= 109`
- `add` ，`edit` ，`rmv` 和 `execTop` 的总操作次数 **加起来** 不超过 `2 * 105` 次。
- 输入保证 `taskId` 是合法的。

# 解题思路

当任务被修改或删除时，不会直接操作堆（因为堆不支持高效的中间元素修改或删除）。修改时元素重新入堆实现了这一点。
而是通过哈希表记录任务的最新状态，堆中可能存在过时的任务信息。
在执行任务时（execTop方法），通过哈希表验证任务的有效性，过滤掉过时的任务。

```
class TaskManager {
private:
    // 存储任务的详细信息：key为taskId，value为{priority(优先级), userId(用户ID)}
    // 用于快速查找、更新和删除任务信息
    unordered_map<int, pair<int, int>> taskInfo;
    
    // 最大优先级队列：存储{priority, taskId}，用于获取当前优先级最高的任务
    // 优先级高的任务会被优先执行（数值越大优先级越高）
    priority_queue<pair<int, int>> heap;
    
public:
    // 构造函数：初始化任务管理器
    // 参数tasks是一个二维向量，每个元素格式为[userId, taskId, priority]
    TaskManager(vector<vector<int>> tasks) {
        // 遍历所有初始任务，将其添加到数据结构中
        for (auto& task : tasks) {
            int userId = task[0], taskId = task[1], priority = task[2];
            // 存储任务信息到哈希表
            taskInfo[taskId] = {priority, userId};
            // 将任务添加到优先级队列
            heap.emplace(priority, taskId);
        }
    }
    
    // 添加新任务
    // 参数：userId(用户ID), taskId(任务ID), priority(优先级)
    void add(int userId, int taskId, int priority) {
        // 存储任务信息到哈希表
        taskInfo[taskId] = {priority, userId};
        // 将任务添加到优先级队列
        heap.emplace(priority, taskId);
    }
    
    // 修改任务的优先级
    // 参数：taskId(任务ID), newPriority(新的优先级)
    void edit(int taskId, int newPriority) {
        // 检查任务是否存在
        if (taskInfo.find(taskId) != taskInfo.end()) {
            // 更新哈希表中任务的优先级
            taskInfo[taskId].first = newPriority;
            // 将新的优先级信息加入队列（旧的记录会在执行时被过滤）
            heap.emplace(newPriority, taskId);
        }
    }
    
    // 删除指定任务
    // 参数：taskId(任务ID)
    void rmv(int taskId) {
        // 从哈希表中删除任务信息
        taskInfo.erase(taskId);
    }
    
    // 执行当前优先级最高的任务，并返回该任务所属的用户ID
    // 返回值：任务所属的userId，若没有可执行任务则返回-1
    int execTop() {
        // 循环直到找到有效的任务或队列为空
        while (!heap.empty()) {
            // 获取队列顶部的任务（当前优先级最高）
            auto [priority, taskId] = heap.top();
            heap.pop();
            
            // 检查任务是否有效：
            // 1. 任务存在于哈希表中（未被删除）
            // 2. 队列中的优先级与哈希表中的最新优先级一致（未被修改过）
            if (taskInfo.find(taskId) != taskInfo.end() && 
                taskInfo[taskId].first == priority) {
                // 获取任务所属用户ID
                int userId = taskInfo[taskId].second;
                // 从哈希表中删除已执行的任务
                taskInfo.erase(taskId);
                // 返回用户ID
                return userId;
            }
            // 如果任务无效（已删除或优先级已修改），则继续检查下一个任务
        }
        // 没有可执行的任务，返回-1
        return -1;
    }
};
```

复杂度分析

- 时间复杂度：O() 
- 令 n 为初始化时 tasks 的长度，m 为后续操作的次数。初始化消耗 O(n×logn)，add 消耗 O(log(n+m))，edit 消耗 O(log(n+m))，rmv 消耗 O(1))，execTop 均摊消耗 O(log(n+m))。

- 空间复杂度：O(m+n)
