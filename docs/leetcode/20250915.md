---
date: 2025-09-15
category:
  - LeetCode每日一题
tag:
  - 字符串
  - 哈希表
  - 数组
---

# [1935. 可以输入的最大单词数](https://leetcode.cn/problems/maximum-number-of-words-you-can-type/)

已解答

简单



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



提示



键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。

给你一个由若干单词组成的字符串 `text` ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 `brokenLetters` ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 `text` 中单词的数目。

 

**示例 1：**

```
输入：text = "hello world", brokenLetters = "ad"
输出：1
解释：无法输入 "world" ，因为字母键 'd' 已损坏。
```

**示例 2：**

```
输入：text = "leet code", brokenLetters = "lt"
输出：1
解释：无法输入 "leet" ，因为字母键 'l' 和 't' 已损坏。
```

**示例 3：**

```
输入：text = "leet code", brokenLetters = "e"
输出：0
解释：无法输入任何单词，因为字母键 'e' 已损坏。
```

 

**提示：**

- `1 <= text.length <= 104`
- `0 <= brokenLetters.length <= 26`
- `text` 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
- 每个单词仅由小写英文字母组成
- `brokenLetters` 由 **互不相同** 的小写英文字母组成

# 解题思路

先构造unordered_set，可以用string的迭代器实现循环insert的效果。

判断时，使用count（返回是否存在，集合会去重）而不是find（返回的是迭代器）

```
class Solution {
public:
    int canBeTypedWords(string text, string brokenLetters) {
        unordered_set<char> broken(brokenLetters.begin(),brokenLetters.end());
        int ans=0;
        bool check=true;
        for(char ch:text){
            if(ch==' '){ // 完成一个单词的检查，判断是否能拼出，check置为true处理下一个的单词
                if(check){
                    ans++;
                }
                check=true;
            }else if(broken.count(ch)){
                check=false;
            }
        }
        if(check){  // 最后一个单词后面没有空格，单独判断
            ans++;
        }
        return ans;
    }
};
```

复杂度分析

- 时间复杂度：O(m+n) 先遍历加到set，再遍历判断
- 空间复杂度：O(n)
