---
date: 2025-10-17
category:
  - LeetCode每日一题
tag:
  - 字符串
  - DFS
  - 动态规划
---

# [3003. 执行操作后的最大分割数量](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/)

给你一个下标从 **0** 开始的字符串 `s` 和一个整数 `k`。

你需要执行以下分割操作，直到字符串 `s `变为 **空**：

- 选择 `s` 的最长 **前缀**，该前缀最多包含 `k `个 **不同** 字符。
- **删除** 这个前缀，并将分割数量加一。如果有剩余字符，它们在 `s` 中保持原来的顺序。

执行操作之 **前** ，你可以将 `s` 中 **至多一处** 下标的对应字符更改为另一个小写英文字母。

在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的 **最大** 分割数量。

 

**示例 1：**

**输入：**s = "accca", k = 2

**输出：**3

**解释：**

最好的方式是把 `s[2]` 变为除了 a 和 c 之外的东西，比如 b。然后它变成了 `"acbca"`。

然后我们执行以下操作：

1. 最多包含 2 个不同字符的最长前缀是 `"ac"`，我们删除它然后 `s` 变为 `"bca"`。
2. 现在最多包含 2 个不同字符的最长前缀是 `"bc"`，所以我们删除它然后 `s` 变为 `"a"`。
3. 最后，我们删除 `"a"` 并且 `s` 变成空串，所以该过程结束。

进行操作时，字符串被分成 3 个部分，所以答案是 3。

**示例 2：**

**输入：**s = "aabaab", k = 3

**输出：**1

**解释：**

一开始 `s` 包含 2 个不同的字符，所以无论我们改变哪个， 它最多包含 3 个不同字符，因此最多包含 3 个不同字符的最长前缀始终是所有字符，因此答案是 1。

**示例 3：**

**输入：**s = "xxyz", k = 1

**输出：**4

**解释：**

最好的方式是将 `s[0]` 或 `s[1]` 变为 `s` 中字符以外的东西，例如将 `s[0]` 变为 `w`。

然后 `s` 变为 `"wxyz"`，包含 4 个不同的字符，所以当 `k` 为 1，它将分为 4 个部分。

 

**提示：**

- `1 <= s.length <= 104`
- `s` 只包含小写英文字母。
- `1 <= k <= 26`

# 解题思路

记忆化搜索

```
class Solution {
public:
    int maxPartitionsAfterOperations(string s, int k) {
        unordered_map<long long, int> memo;
        auto dfs = [&](this auto&& dfs, int i, int mask, bool changed) -> int {
            if (i == s.length()) {
                return 1;
            }

            // 把参数压缩到一个 long long 中，方便作为哈希表的 key
            long long args = (long long) i << 32 | mask << 1 | changed;
            auto it = memo.find(args);
            if (it != memo.end()) { // 之前计算过
                return it->second;
            }

            int res;
            // 不改 s[i]
            int bit = 1 << (s[i] - 'a');
            int new_mask = mask | bit;
            if (popcount((uint32_t) new_mask) > k) {
                // 分割出一个子串，这个子串的最后一个字母在 i-1
                // s[i] 作为下一段的第一个字母，也就是 bit 作为下一段的 mask 的初始值
                res = dfs(i + 1, bit, changed) + 1;
            } else { // 不分割
                res = dfs(i + 1, new_mask, changed);
            }

            if (!changed) {
                // 枚举把 s[i] 改成 a,b,c,...,z
                for (int j = 0; j < 26; j++) {
                    new_mask = mask | (1 << j);
                    if (popcount((uint32_t) new_mask) > k) {
                        // 分割出一个子串，这个子串的最后一个字母在 i-1
                        // j 作为下一段的第一个字母，也就是 1<<j 作为下一段的 mask 的初始值
                        res = max(res, dfs(i + 1, 1 << j, true) + 1);
                    } else { // 不分割
                        res = max(res, dfs(i + 1, new_mask, true));
                    }
                }
            }

            return memo[args] = res; // 记忆化
        };
        return dfs(0, 0, false);
    }
};
```

复杂度分析


- 时间复杂度：O(Mn) 复杂度取决于用到的字母数M，最多为26
- 空间复杂度：O(n)
