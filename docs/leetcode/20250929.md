---
date: 2025-09-29
category:
  - LeetCode每日一题
tag:
  - 动态规划
  - 数组
---

# [1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

你有一个凸的 `n` 边形，其每个顶点都有一个整数值。给定一个整数数组 `values` ，其中 `values[i]` 是第 `i` 个顶点的值（即 **顺时针顺序** ）。

假设将多边形 **剖分** 为 `n - 2` 个三角形。对于每个三角形，该三角形的值是顶点标记的**乘积**，三角剖分的分数是进行三角剖分后所有 `n - 2` 个三角形的值之和。

返回 *多边形进行三角剖分后可以得到的最低分* 。
 



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/25/shape1.jpg)

```
输入：values = [1,2,3]
输出：6
解释：多边形已经三角化，唯一三角形的分数为 6。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/25/shape2.jpg)

```
输入：values = [3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/02/25/shape3.jpg)

```
输入：values = [1,3,1,4,1,5]
输出：13
解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。
```

 

**提示：**

- `n == values.length`
- `3 <= n <= 50`
- `1 <= values[i] <= 100`

# 解题思路

记忆化dfs

先以数组头尾确定一条边，遍历其他所有的顶点，分割成子问题继续处理。

同时，处理过的数据记录在memo数组中。dfs(i,j)表示从i到j这个多边形最小的划分数值。

```
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n=values.size();
        // C++17语法可以写成vector memo(n,vector<int>(n,-1)); 使用构造函数默认推断memo的数据类型
        vector<vector<int>> memo(n,vector<int>(n,-1));
		
		// lambda表达式
		// auto自动接收dfs的类型，即lambda函数。这里并不代表返回值的类型
		// [&]表示任何被使用到的外部变量都隐式地以引用方式加以引用，这里完成了对参数values和定义的变量n，memo的捕获
		// this auto&& 使得该dfs函数可以被自身递归调用
		// ->int表示返回值类型是int
        auto dfs=[&](this auto&& dfs,int i,int j)->int{
            if(i+1==j){
                return 0;
            }
            // 直接引用memo数组，在后面循环取最小值时计算res直接就能更新memo
            int& res=memo[i][j];
            if(res!=-1){
                return res;
            }
            res=INT_MAX;
            for(int k=i+1;k<j;k++){
                 res=min(res,dfs(i,k)+dfs(k,j)+values[i]*values[j]*values[k]);
            }
            return res;
        };
        return dfs(0,n-1);
    }
};
```

复杂度分析


- 时间复杂度：O(n^3) memo存储n^2个状态，每个状态遍历需要n 
- 空间复杂度：O(n^2)
