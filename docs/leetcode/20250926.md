---
date: 2025-09-26
category:
  - LeetCode每日一题
tag:
  - 数组
  - 排序
  - 双指针
---

# [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

 

**示例 1:**

```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

**示例 2:**

```
输入: nums = [4,2,3,4]
输出: 4
```

 

**提示:**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

# 解题思路

1. **排序**🧠
   先对数组排序，这样可以保证对于任意 i < j < k，都有 `nums[i] ≤ nums[j] ≤ nums[k]`。
   这样我们只需检查 `nums[i] + nums[j] > nums[k]` 是否成立。
2. **固定两个较小的边，找最大的合法第三边**
   - 外层循环固定最小边 `i`
   - 内层循环固定中间边 `j`（j > i）
   - 然后找最大的 `k`（k > j），使得 `nums[i] + nums[j] > nums[k]`
3. **使用双指针优化**
   关键优化点：**k 不需要每次都从 j+1 重新开始找**。
   因为当 j 增大时，`nums[i] + nums[j]` 也增大（数组已排序），所以满足条件的 k 只会**向右移动**（单调不减）。
   所以我们可以让 `k` 在整个过程中只向前走，实现 **O(n²)** 时间复杂度。

```
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int k = i;
            for (int j = i + 1; j < n; ++j) {
                while (k + 1 < n && nums[k + 1] < nums[i] + nums[j]) {
                    ++k;
                }
                ans += max(k - j, 0);
            }
        }
        return ans;
    }
};
```

复杂度分析


- 时间复杂度：O(n²) ，先用nlogn排序，再用n²双指针遍历
- 空间复杂度：O(logn)，排序用到的空间
